[{"categories":["Notes"],"content":"Zotero的安装和使用","date":"2022-01-27","objectID":"/zotero/","tags":["Tools"],"title":"Zotero的使用","uri":"/zotero/"},{"categories":["Notes"],"content":"Zotero Zotero是一款开源文献管理软件，功能和EndNote相似，但是其丰富的插件使其具有十分强大的功能。 到官网（Zotero | Downloads）下载对应版本的Zotero和浏览器插件。 按照网上教程安装Zotero插件，参考连接如下： Zotero的插件介绍 - 知乎 (zhihu.com) 安装quicklook后点击空格就可以预览。 Zotero网盘同步及文件夹重命名 - 知乎 (zhihu.com) 所有文件都存储到了onedrive的文件夹下。 下载坚果云客户端，配置文件夹可以达到同样的效果。 ","date":"2022-01-27","objectID":"/zotero/:0:0","tags":["Tools"],"title":"Zotero的使用","uri":"/zotero/"},{"categories":["Tutorial"],"content":"Install Hugo on Wins and build your own website!","date":"2022-01-17","objectID":"/build_websites_with_hugo/","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Build our own website by using Hugo on Wins Hugo is said to be the world’s fastest framework for building websites. The world’s fastest framework for building websites | Hugo (gohugo.io) ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:1:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Install Hugo There are so many tutorials for installing hugo on macOS and Linux, and this blog mainly fucuses on how to install hugo on Windows. And I recommend using method two. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Method One： Using Official Docs Hugo official installation file： Install Hugo | Hugo (gohugo.io) First, make sure you have chocolatey on your laptop with Windows system. 1. Install chocolatey on Windows Chocolatey Software Docs | Setup / Install Please remember to start a command prompt as an administrator. run the following command: @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Check whether hugo is installed successfully with the following command: choco help 2.Install Hugo with Chocolatey If you are on a Windows machine and use Chocolatey for package management, you can install Hugo with the following one-liner: install-with-chocolatey.ps1 choco install hugo -confirm Or if you need the “extended” Sass/SCSS version: install-extended-with-chocolatey.ps1 choco install hugo-extended -confirm ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:1","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Method Two：Download hugo.exe directly 1.Download Hugo Releases · gohugoio/hugo (github.com) Download the certain version you need. Some website themes have requirements of hugo version. 2. Set Environment Variables Set the folder of hugo.exe as environment variables. Then, open another command line to check whether it is successfully set or not. Run the command in CMD: hugo version ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:2","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Themes I Prefered There are many themes on the official websites. Complete List | Hugo Themes (gohugo.io) Personally I prefered the following themes. Academic | Hugo Themes (gohugo.io) Academic | Hugo Themes (gohugo.io) PaperMod | Hugo Themes (gohugo.io) Even | Hugo Themes (gohugo.io) Tranquilpeak | Hugo Themes (gohugo.io) Clean White | Hugo Themes (gohugo.io) LoveIt | Hugo Themes (gohugo.io) I use the theme LoveIt. LoveIt (hugoloveit.com) Install it according to the official document and try to build demo yourself. Theme Documentation - Basics - LoveIt (hugoloveit.com) You can also follow the steps in this video. Although it is on the MacOS system, she explained everything clearly in Chinese. Hugo - 10分钟搭建 \u0026 部署个人网站/博客，简历中的博客网站怎么建哔哩哔哩bilibili ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:3:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Memos ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Important Command 1.hugo serve Executehugo serve under the root folder of the project, click http://localhost:1313/ to visit your website locally. 2.hugo make sure that in the config.toml , it is written like baseUrl=“https://[username].github.io” Executehugo under the root folder of the project. For the first time you do it, the public folder will be made. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:1","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Publish on GitHub Pages new a repository，setting it to public。 Set the address of your blog [username].github.io at setting/pages. Set the branch to master if you use it. Executehugo under the root folder of the project. For the first time you do it, the public folder will be made.(make sure that in the config.toml , it is written like baseUrl=“https://[username].github.io”) cd public, run the command: git init git add . git commit -m\"first commit\" git add remote origin \"your reposotory address\" git push -u origin master Wait a few minites，and you can visit your website on https://[username].github.io. tips: If the your website doesn’t change after a sucessful push, please check the actions of repository. The compiling of new github pages probably failed. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:2","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Some mistakes I met If the style/css of the website went wrong, you should check the url and address in index.html page. Perhaps the baseUrl is wrong. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:3","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"The Extended Functions of LoveIt： Hugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 - Yulin Lewis' Blog (lewky.cn) There are four blogs in the link , including the improvements of searching！ The official link is also helpful. Theme Documentation - Extended Shortcodes - LoveIt (hugoloveit.com) Save My config.toml I revise the config.toml according to the offical demo and files, including: [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"xxx\" [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"xxx\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否保持使用文章前面的静态目录 keepStatic = false [params.list] # list 页面每页显示文章数量 paginate = 10 ... Here is my config.toml I delete the function of comments, because it goes wrong on github pages. baseURL = \"https://xxx.github.io/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" title = \"xxx's blog\" # Change the default theme to be use when building the site with Hugo theme = [\"hugo-search-fuse-js\",\"LoveIt\"] # whether to use emoji code # 是否使用 emoji 代码 enableEmoji = true [menu] [[menu.main]] identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"projects\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Projects\" url = \"/categories/projects/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [[menu.main]] identifier = \"about\" pre = \"\" post = \"\" name = \"About\" url = \"/about/\" title = \"\" weight = 5 [[menu.main]] pre = \"\u003ci class='fas fa-fw fa-search'\u003e\u003c/i\u003e\" name = \"search\" weight = 7 identifier = \"search\" url = \"/search/\" [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = false # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Isaray's blog\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:4","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Notes"],"content":"递归、分治、贪心、回溯、动态规划和枚举","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.递归 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.1算法策略 把问题分解成更小规模的同类子问题，用递归调用的方法求解问题。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.2 适用场景 引用知乎一篇文章的总结 递归算法一般用于解决三类问题： 数据的定义是按递归定义的。（斐波那契数列） 问题解法按递归算法实现。（回溯） 数据的结构形式是按递归定义的。（树的遍历，图的搜索） 解题策略 （1）明确输入输出 （2）明确递归结束条件 （3）明确递归关系式 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.3经典问题 斐波那契数列 汉诺塔问题 树的遍历及相关操作 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.分治 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.1算法策略 将一个问题分解成多个子问题，每个子问题又可以分解成更小的子问题，直到子问题可以被求解。原问题是子问题的合并。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.2适用场景 当出现满足以下条件的问题，可以尝试只用分治策略进行求解： 原始问题可以分成多个相似的子问题 子问题可以很简单的求解 原始问题的解是子问题解的合并 各个子问题是相互独立的，不包含相同的子问题 解题策略 分解大问题 解决子问题 合并子问题结果 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.3经典问题 二分查找 归并排序 快速排序 汉诺塔问题 React 时间分片 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.贪心 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.1算法策略 总是选择当下最优的解决方案。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.2适用场景 当满足一下条件时，可以使用： 原问题复杂度过高 求全局最优解的数学模型难以建立或计算量过大 没有太大必要一定要求出全局最优解，“比较优”就可以 解题策略 定义最优解条件 把问题分解成多个步骤，每一步要满足 可行性：每一步都满足问题的约束 局部最优 不可取消 最后叠加所有步骤得到最优解。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.3经典问题 使用贪心算法求解的经典问题有： 最小生成树算法 单源最短路径的 Dijkstra 算法 Huffman 压缩编码 背包问题 活动选择问题等 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.回溯 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.1算法策略 步步尝试，不行回退。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.2适用场景 不断的尝试，直到拿到解。从一组可能的解中，选择一个满足要求的解。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.3经典问题 深度优先搜索 0-1背包问题 正则表达式匹配 八皇后 数独 全排列 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.动态规划 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.1算法策略 Taking notes. 将复杂问题分解成小问题求解，各个子问题之间有重合，结果可以复用。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.2适用场景 求解最优解。 解题策略 需要遵循以下几个重要步骤： 定义子问题 实现需要反复执行解决的子子问题部分 识别并求解出边界条件 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.3经典问题 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现） ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.枚举 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.1算法策略 一一列举，明确列举范围。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.3经典问题 参考： 95% 的算法都是基于这 6 种算法思想！！！ - 知乎 (zhihu.com) BAT机器学习面试1000题系列_HuangQinJian-CSDN博客_bat机器学习1000题 剑指offer-Python版（上） - 知乎 (zhihu.com) ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.bfs,dfs dfs可以看作不知道层数情况下的枚举法，用到递归的思想。 全排列 class Solution2: def permute(self, nums: List[int]) -\u003e List[List[int]]: res = [] def backtrack(nums, tmp): if not nums: res.append(tmp) return for i in range(len(nums)): backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]]) backtrack(nums, []) return res 岛屿数量 class Solution: def numIslands(self, grid): row, col, ret = len(grid), len(grid[0]), 0 def dfs(x, y): grid[x][y] = '0' for c in [[0, 1], [0, -1], [1, 0], [-1, 0]]: nx, ny = x + c[0], y + c[1] if 0 \u003c= nx \u003c row and 0 \u003c= ny \u003c col and grid[nx][ny] == '1': dfs(nx, ny) for i in range(row): for j in range(col): if grid[i][j] == '1': dfs(i, j) ret += 1 return ret ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.binary search 求x的平方根 class Solution: def mySqrt(self, x: int) -\u003e int: l, r, ans = 0, x, -1 while l \u003c= r: mid = (l + r) // 2 if mid * mid \u003c= x: ans = mid l = mid + 1 else: r = mid - 1 return ans ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:4","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.sliding window move them simutanously 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 class Solution: def lengthOfLongestSubstring(self, s: str) -\u003e int: cur, res = [], 0 for r in range(len(s)): while s[r] in cur: cur.pop(0) # 左边出 cur.append(s[r]) # 右侧无论如何都会进入新的 res = max(len(cur),res) return res recursion fibonacci, binary tree class Solution: def hanota(self, A: List[int], B: List[int], C: List[int]) -\u003e None: \"\"\" Do not return anything, modify C in-place instead. \"\"\" n = len(A) self.move(n, A, B, C) def move(self, n, A, B, C): if n == 1: C.append(A.pop()) else: self.move(n-1, A, C, B) C.append(A.pop()) self.move(n-1, B, A, C) inverting into binary tree reverse a linked list class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 申请两个节点，pre和 cur，pre指向None pre = None cur = head # 遍历链表，while循环里面的内容其实可以写成一行 # 这里只做演示，就不搞那么骚气的写法了 while cur: # 记录当前节点的下一个节点 tmp = cur.next # 然后将当前节点指向pre cur.next = pre # pre和cur节点都前进一位 pre = cur cur = tmp return pre suffix trees class Trie: def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix: str) -\u003e \"Trie\": node = self for ch in prefix: ch = ord(ch) - ord(\"a\") if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word: str) -\u003e None: node = self for ch in word: ch = ord(ch) - ord(\"a\") if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word: str) -\u003e bool: node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix: str) -\u003e bool: return self.searchPrefix(prefix) is not None heaps repeatedly find min,max 第 k 个最大的元素 class Solution: def findKthLargest(self, nums: List[int], k: int) -\u003e int: # 构造大小为 k 的小顶堆 heap = [x for x in nums[:k]] heapq.heapify(heap) n = len(nums) for i in range(k, n): if nums[i] \u003e heap[0]: heapq.heappop(heap) heapq.heappush(heap, nums[i]) return heap[0] dynamic programming sorting algorithm quick sort and merge sort ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:5","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Courses"],"content":"算法导论复习","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"算法导论【复习】 教材：算法导论第三版 本博客内容均为自行整理，以供学过算法的同学快速回忆之用。 本人第一篇博客，当然要献给算法啦！博客是在复习的时候整理的，有点类似于记忆碎片，比较简略，欢迎大家在评论区讨论、补充、纠正。 ](算法导论期末复习大纲) ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:0:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【算法复杂度】： 假设所需计算机资源的量只和问题规模、算法输入和算法本身的函数相关。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:1:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"时间复杂度： 用基本操作步数衡量，独立于机器。 在不同情况下算法复杂度也是不同的，常见的情况有最好情况下，平均情况下，最坏情况下的时间复杂度。 首先，是时间复杂度的三个概念O(),$\\theta$(),$\\omega$()。 【算法导论】P26，三张图有助于理解 - $O$() 渐进上界 {f(n):存在正常量c,$n_0$，使得对所有n\u003e=$n_0$，有0\u003c=f(n)\u003c=cg(n)} - $\\theta$() 渐进紧确界 {f(n):存在正常量$c_1$、$c_2$和$n_0$，使得对所有n\u003e=$n_0$，有0\u003c=$c_1$g(n)\u003c=f(n)\u003c=$c_2$g(n)} - $\\Omega$() 渐进下界 {f(n):存在正常量c,$n_0$，使得对所有n\u003e=$n_0$，有0\u003c=cg(n)\u003c=f(n)} 另外： 1.$\\omicron$()代表非渐进紧确上界，$\\omega$()代表非渐进紧确下界。o(g(n)) = {f(n): 对任意正常数c\u003e0，使得对所有n\u003e=$n_0$，有0\u003c=f(n)\u003ccg(n)} 2.$O()$和$\\Omega$()如果非常紧的话都会趋向于$\\theta$()。（有一种紧确界的证明方式就是这样的） 3.$O()$往往差了些也是对的，但是不准确，比如用O($n^{100}$)来描述快速排序的平均时间复杂度也是对的,但是不如O(nlogn)来得确切。所以比较紧的界才有意义，能求出$\\theta$()最好啦。（另外，用$o(nlogn)$来描述快速排序的平均情况就不行，因为$\\omicron$()代表非渐进紧确上界，看那个定义中是没有等号的，要注意大O和小o的区别）。 根据递归式求$O$()和 $\\Omega$()的三种方法： 代入法P48：猜测复杂度式子，假设出来（可能需要带低阶的参数），代入递归式并证明。 递归树法P50：把递归树画出来，然后累加（可能会用到级数相关知识）。那种分成两颗不均匀子树的情况常用这种方法求解。 主方法P53：可以用递归树法推导，推导过程中会用到$n^{log_ba} = a^{log_bn}$的性质P56。 令a$\\ge$1和b\u003e1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： T(n) = a * T(n/b) + f(n)，其中我们将n/b解释为$\\lfloor n/b\\rfloor$或者$\\lceil n/b\\rceil$。那么T(n)有如下渐进界。 对某个常数$\\epsilon\u003e0$，有 f(n) = $O(n^{log_ba−\\epsilon})$, 则 T(n) = $\\theta(n^{log_ba})$。（叶子节点占主导） f(n) = $\\theta(n^{log_ba})$, 则 T(n) = $\\theta(n^{log_ba}logn)$ 。（根节点叶子结点差不多） 对某个常数$\\epsilon\u003e0$，有 f(n) = $\\Omega(n^{log_ba−\\epsilon})$, 且对某个常数c\u003c1和所有足够大的n有$af(n/b)\\le cf(n)$，则 T(n) = $\\theta(f(n))$。（根节点占主导） strassen算法 书中有穿插着讲矩阵乘法的strassen算法，以它的复杂度为例。P44有伪代码。一般针对方阵，不是方阵可以补成方阵。 为什么要strassen算法？可能是因为原来效率太低了$O(n^3)$，即使做分块运算效率也很低，用加入一些矩阵加法的运算，减少矩阵乘法的运算的方法来提高效率，用strassen做矩阵乘法可以达到$O(n^{log_27})$相当于$O(n^{2.81})$。strassen算法就是运用了分而治之的思想将矩阵分块套公式运算，本质上还是“简化”的矩阵乘法。 为什么strassen算法的时间复杂度是线性的？P124（1/5+7/10\u003c1）继续迭代下去就是线性的。 博主用c语言实现了一下strassen算法，按照伪代码的思路没问题，就定义一下矩阵的加法、减法和乘法运算就可以了，在2^11次规模下真的很慢，要运行将近一个小时，比普通乘法还慢（即使用strassen算法，在较小规模的情况下可以还是使用普通乘法）。有同学用c++里的vector来实现，好像速度还挺快，以后可以尝试一下。 另外：做课后习题的时候，需要掌握简单的级数展开的知识，可以看一下前几章的内容。 lg(n!)=$\\theta$(nlgn)课后习题会用到。 有的时候还要用到高中求解数列通项公式的技巧，同除啊换元啊什么的。 说实话，算法里有很多内容在离散数学中都讲过，感觉又温习了一遍！ P54页上有提到“非多项式意义上大于”的问题（ T(n)=2T(n/2)+nlogn，nlogn并不在多项式意义上大于n），不能用主方法，但可以用递归树方法求解。具体的话，看书啦。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:1:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"空间复杂度： 在此不加以赘述。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:1:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"高级分析技巧【摊还分析】： Ask：三种摊还分析的方法具体指的是什么？ Ans：聚合分析、核算法、势能法。 聚合分析： 先算出一些操作的总数上限，取平均值。（有很多操作，打包计算） 核算法： 对某些操作多分配一些代价，下次可以从信用里面取代价。（有几种操作，操作复杂度差不多，让简单操作多算几个，预支一些复杂操作的信用，简化分析过程） 势能法： 定义一个势能函数。 以书中push、pop、multipop为例，他是以栈中还有多少个元素为势函数。$c_i$和$c_i^{hat}$一个表示真实开销一个表示上界。 动态表： Ask:动态表有什么用？ Ans:对到底需要分配多少空间，心里没有数，动态表不够用了可以扩张，存的内容变少了也可以缩减表空间。 课后习题：第一题，pultipush()不是O(1)，因为不知道push多少个，如果改成multipush_5()的摊还分析，还是O(1)的级别。 n个操作合起来的代价，和一个操作的代价题目要看清楚。 找中转站的思维：分两步解决问题，1-\u003e2,2-\u003e3，则1-\u003e3，例如所有线路都通过人民广场，那么所有站点都相互可达。（所有问题都可以转换为一个问题，那个问题又有某种性质，那么所有问题都具有这种性质）。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:1:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"算法分析：概率分析和随机算法 经典例题： 生日问题：用逆向思维。课后例题经典，概率论中也会学习。P73。练习5.4-1 球与箱子 特征序列 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:1:4","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【排序算法】： 基于比较的排序算法平均时间复杂度最小为O(nlgn)，基于非比较的排序平均时间复杂度最小为O(n). ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:2:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"基于比较的排序： 1. 插入排序 Insertion sort 给定一个数组，每次把新来的数插入之前已经排好的序列中，从只有一个数的序列直到把所有数都排列进去。例如，洗牌。 时间复杂度$O(n^2)$ 2. 选择排序 头部已排好序，尾部未排好序，每次从未排好序的里面选最值放到已排好序的序列尾端。 时间复杂度$O(n^2)$ 3. 冒泡排序 两重循环，两两比较，每次最值沉底或上浮。 时间复杂度$O(n^2)$ 4. 归并排序 留到分治策略那一部分详细叙述。 分解：n-\u003en/2 解决：使用归并排序递归地排序两个子序列 合并：合并两个排好序的子序列 5. 快速排序 （重点） 跟基准元比较，分成前后两堆，比基准元小的和比基准元大的。 老师在答疑课上问到我了，我应该这辈子都不会忘了。 我被问到的问题→存不存在一种算法的平均情况下的时间复杂度和最坏情况下的时间复杂度不一样？举个例子。 我回答了快速排序。 平均情况下的时间复杂度：O($nlgn$) 最坏情况下的时间复杂度：O($n^2$)。如何达到？ 基准元选的不好，每次都是最大值或者是最小值，每次两边分布一边很多一边很少。每次从小到大或者是从大到小排的数组，效果比较差。每次首尾和基准元比大小，不对就交换 随机选取基准元的快速排序。随机选取基准元平均情况O($nlgn$)，最差情况也是O($n^2$)。 为了防止有人蓄意构造一个序列，使得快速排序变成最坏情况，我们可以随机选取基准元，**random_select()**算法。 6. 堆排序 建堆的复杂度：O(n) 堆一般用数组存储 大顶堆：根节点的值比叶子节点的值大 注意几个函数即可，建堆的时候从1/2处（第一个有孩子的结点）往上调整，和孩子比较，max-heapify() 堆排序就是构造完大顶堆之后，extract-max()和数组最后一个交换，heapsize- -，然后再对根max-heapify()，以此类推。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:2:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"基于非比较的排序： Ask：为什么非比较排序的复杂度可以到达O(n)是不是很神奇？有什么需要满足的条件吗？ - 排序算法为什么可以到O(n)，这不是很奇怪吗？ Ans:非比较排序的【前提】：输入数据的种类总是有限的、有一定范围的，列举一下算法的例子，例如人的身高统计，统计到厘米的精度，还是0.0000001的精度，范围很大就不一定行了。基于非比较的排序实际上是把问题范围从大问题缩小到小问题，用空间换时间。 Ask：基于比较的排序算法有一棵树，长什么样子？P107 Ans:路径的长度就是比较的次数，每个叶子节点就是输入的排序。排列组合，三个数有多少种排列，3！。多少种排序情况，就有多少个叶子结点，要经过多少次查找才能找到。 7.计数排序 有一定条件，元素个数和种类是指定的。基于统计的排序。 确定数字种类，分别统计数量，在新的数组的相应位置插入这个数字。 8.基数排序 把数分为几个部分，分别排序。例如一个三位数，先排个位再排十位，最后排百位。 分成几个位数，有限个。先排最低位。在d和k参数。。 9.桶排序 P119找最小值，找最大值，要找n次。同时找最小值和最大值，实际上只用找1.5n次。方法：取两个数，其中大的之和最大值比，小的之和最小值比。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:2:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【中位数和顺序统计量】： 如何求中位数： 方法一：先排序，排序。 方法二：select算法 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:3:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"RANDOMIZED-SELECT O(n)的复杂度。 用了快速排序的partition方法，分两段。 可以用于找中位数，但是扩展来说找1/4，1/3位置的数都可以。找分位数的可以用于设计等高的直方图，更方便描述数据集合的轮廓。设计等高直方图，找n次SELECT可以达到O(n),也可以直接排序有O(nlogn)的复杂度，所以O(min(nlogn,n))。有多种方法哦！不要思维定势。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:3:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"SELECT()算法，期望为线性时间 五个五个分组，每组排好序，找中位数，去掉四分之三不用比较的，再继续。 复杂度是O(n) 最坏时间为线性时间，暂时不考试。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:3:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【查找算法】 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:4:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"顺序查找 一般基于数组，无序的数组就可。O(n) ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:4:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"二分查找 一般基于数组，但是要有序的数组。 插入删除查询的复杂度来分析两个算法。插入：顺序查找要O(1)插在最后一位，二分查找是有序的，平均O(n)的开销。如果删了不移动，分别是O(n)和O(logn)，如果删了要移动，则都是O(n)。查找代价分别是O(n)和O(logn)。 **二叉搜索树的性能来对比，二叉搜索树不是重点，不能保证任何一个复杂度，我们寻求的终点是二叉平衡树！！！**插入、删除、修改全部可以变成O(logn)。二叉搜索树可以达到O(logn)这个是不对的。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:4:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"哈希查找 直接寻址法；除留余数法；开放寻址法（线性探测，二次探查，双双重散列），再哈希法 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:4:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【分治策略】 分治算法怎么理解？ 举几个例子：归并排序，快速排序，strassen算法的矩阵乘法。 strassen算法O($n^{log7}$)=O($n^{2.81}$)很有名 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:5:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【动态规划】 和分治算法的区别就是子问题可以复用。例如，分治算法的矩阵乘法，分块计算就不相关。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:6:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"经典问题： 钢条切割问题 假设0-9米的钢条情况都已经知道了，到10划分最优子结构也知道了。 矩阵链的乘法 完全背包问题（贪心算法不能达到最优）： 价值、体积、背包大小。子体积的最优解全部记录下来。 最长公共子序列 用一个二维的矩阵记录，一行一行来，然后有一个表达式，就是(i,j)的值和(i-1,j)和(i,j-1)相关，如果这一位刚好相等，在两者较大的哪个基础上加1即可，不相同取其中较大的那个即可。在写算法的时候一路走，一路会记录方向，方便往回找。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:6:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【贪心算法】 每次都做了局部最优得选择，但不一定是全局最优的。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:7:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"经典问题： 活动选择问题/会议调度安排问题： 选择最早开始或者最不冲突的是无法达到全局最优的，但是用最早结束的是可以达到最优的。 0-1背包问题和分数背包问题 老师提问→什么问题不能用贪心算法解决？举几个例子。 answer：0-1背包问题，不可用贪心算法解决，要用动态规划的算法解决，但是分数背包问题可以用贪心算法解决。*分数背包问题如何解决？*每次都取性价比最高的装满书包。 赫夫曼编码 为了使文本变短。对频率进行排列。 有一个性质就是头部不冲突，怎么解释？ 前缀码长得不一样，使得编码是唯一的，能识别的。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:7:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【堆】 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:8:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"堆排序（之前提到过） 堆的话一般是数组，堆可以转变成一棵树P84。大顶堆（父结点的值比子结点）、小顶堆。 建堆的复杂度O(n)，$theta(n)$。从第一个有子节点的往上走。 堆排序的开销是O(nlogn)。堆排序的开销不可能是O(logn)。 堆的好处是可以用来做优先级队列。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:8:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"优先队列 一般用堆来实现。 按照key的大小，每次选第一大的。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:8:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"斐波那契堆 除了删除和取最值操作和二叉堆的代价一样，其他操作的均摊代价可以达到O(1)，非常理想。P290 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:8:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【树】 Ask:树和图的最大区别是什么？ Ans：树没有环。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:9:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"二叉搜索树 用堆构成的二叉树，不是二叉搜索树。二叉树是左边小右边大，堆是父节点最小。 二叉树不一定是平衡树，平衡树才是目的！！ 利用二叉搜索树中序遍历输出就是已经排好序的结果。 插入：比较比它则往左边走，比它大则往右边走，直到找到合适的位置。 查找：比较比它则往左边走，比它大则往右边走，直到查找。 删除：有三种案例。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:9:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"红黑树 Ask:为什么红黑树是一个平衡树？ Ans：在红黑树里根节点到叶节点的路径，最长的不会超过最短的两倍，可以看作同一个量级。为什么可以满足这个性质呢？红节点底下只能是黑结点。 什么是黑高？ 从该结点到叶子结点的简单路径，包含相同数目的黑色结点 例如，一颗空的树，插入一个1，那黑高等于几？黑高等于1。因为根节点必须是黑色的（但算黑高的时候，本身不算），Nil结点也是黑色的。 每次插入新的结点都是红色的。 满足几个条件： 1.每个结点要么红，要么黑 2.根节点为黑色 3.叶子结点都为黑色 4.每个红色结点下只能接黑色结点 5.每个点的黑高都相等 最后可以达到相对平衡的程度，最长边最多是最短边的两倍，不会再长了。 红黑树的旋转： 为了维护黑高的性质。 红黑树结点插入的过程，伴随旋转变色的三种情况（若插入红节点，父亲结点也为红）： 1.叔结点是红色。父结点变红色，本身和叔结点变黑色。 2.叔结点是黑色，插入的结点是左孩子，制作左旋转，变case3。 3.叔结点时黑色，插入的结点是右孩子，旋转+变色。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:9:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"AVL树 AVL树可以达到的效果：最短边和最长边的差距不超过1 具体的实现再说吧，了解一下好了 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:9:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"Huffman 树 (贪心算法中也会提到) Ask:Huffman编码是什么？如何实现？ Ans:以往都是用定长码标记，用Huffman 树可以生成变长的前缀码，使得短的编码不是任何长的编码的前缀（代表的key都在叶子节点上，无前缀），又使得出现频率较高的编码长度较短，达到压缩的目的。用贪心算法的思想实现，每次找权重最小的两个结点，合成一个新的权重，再不断地重复上述操作，最后生成一棵树。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:9:4","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【散列表/哈希表】 直接寻址法，给你一个位置，在这个位置上自己扩展。拉链法。 开放寻址法，冲突了之后。线性探查：依次线性往后找；二次探查：后续探查的时候要加一个偏移量，有一个平方；双重散列：有两个散列函数线性组合去查找。反正给了这么多空间，满了就去占别人的空间。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:10:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"发生哈希碰撞时的处理方法（老师提问）： answer：（1）拉链法（链式存储方法）新开一个链表存储（2）开放定址法：在原数组上存储。开放定址法又有一些具体的方法。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:10:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【动态表】 整块扩大和缩小 分析复杂度 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:11:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【图】 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"图的表示： 邻接矩阵：稠密的话可以用它。 邻接链表：稀疏的话可以用它。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"广度优先搜索BFS 广度优先遍历，先找到他所有的子节点，再遍历子节点下一层。 队列 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"深度优先搜索DFS 深度优先遍历，先找到最深的再不断遍历过来。 Ask：旅行商问题里的近似问题的算法，用的是BFS还是DFS？ Ans：旅行商问题，找欧拉回路，找最小生成树，然后双向，再优化替换点，典型的深度遍历。 栈 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"最小生成树 Ask:最小生成树的定义？ Ans：树是没有回路的，和图不同。再图中找到一棵树，总权重最低。 最小生成树有什么用？answer：举个例子，使得所有的结点之间连接成本最低。 Ask:这两个算法的本质是什么？有什么原则？ Ans：本质在于有两个不同的集合，一个是已经选取的边的集合S，一个是未经选取的边的集合E-S，每次选取的边都是连接这两个集合的最短边，它必在最小生成树里，只是选取的策略不同罢了。 Kruskal 每次选取最小的边（只要不是同根，不会形成一条回路）。 最坏情况下：O(mlogm) Prim 从一个结点往外扩展，每次选取S和V-S之间的最短边。 最坏情况下：O($n^2$) ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:4","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"单源最短路径（不能包含负权回路） 首先定义了两个函数：(v.d代表到源点的距离，v.p代表连到该点的上一个点)P377 初始化函数：每个点的v.d=无穷和v.p=nil 松弛函数：如果v.d\u003eu.d+w(u,v)，那么v.d=u.d+w(u,v)，v.p=u。 感觉松弛操作更像拧紧螺丝，把线卷起来。 Bellman-Ford（权值可以为负数）*不考 看书上P379的伪代码就懂了。首先，初始化。而后，对所有边进行松弛操作，这样做V-1次（对所有边的松弛操作）。最后，再对所有边用松弛条件去判断还会不会有变化，有变化则有负环，返回false，无变化则返回true。 可能这样看会觉得挺有道理的，老师课上说的总结才是真的精辟。 此处，长度代表有几条边。 最短路径长度\u003c=k-1 第一次可以找到长度为1的最短路径 第二次可以找到长度为2的最短路径 ...... k-1轮可以算出长度为k-1的最短路径（最长的最短路径最大为k-1） 所以这样一来应该可以算出单源最短路径了。 再进行一轮松弛，如果有变化的话，肯定就是有负环，找不到单元最短路径的情况啦！ 算法复杂度O(VE)。也很显然有很多不必要的操作嘛，就感觉像是穷举。 参考：blog:https://www.cnblogs.com/Jason-Damon/archive/2012/04/21/2460850.html Dijkstra（权值不能为负数） 本质是从一个点不断扩展的过程 Dijkstra就像摊大饼，每次都把最小的纳入（贪心策略），然后做松弛操作。 算法复杂度依赖于优先队列的实现。P386普通线性搜索，总体复杂度O($V^2$)，用二叉堆，O(ElgV)，用斐波那契堆，可以改善到O(VlgV+E)。 最坏情况下：O($n^2$) ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:5","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"所有结点对的最短路径 Floyd-Warshall ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:6","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"最大流和最小切(割) Ask:什么是最大流？ Ans:两个点之间的流量最大，关心能不能运到，不关心运输时间。用FF算法，用增补网络。 几个概念P419的图 残存网络：有残存容量（有流量不论正反，能够为容量增加的最大值）的边组成的网络 增广路径 ：简单来说就是从源结点s到汇点t的一条/几条可以流通的边 切割：把点集分为两部分S和T；净流量（f(S,T)）算s-\u003et减去t-\u003es,容量（c(S,T)）只算s-\u003et的。 每条边上都有最大的限流，边上标注的是流量而不是距离。 最大流：从源结点s到汇点t，所有的可行路加起来，最多可以送多少。 P425图 贪心的找到一条直接去除是不行的。P425有翻转可以循环利用的。可能把非常霸道的一条边去掉了，断了多条边的路。课上有举例子。 P423 最大流最小切割定理 三个等价条件 Ford-Fulkerson算法 初始化增广网络。只要有一条路，就找路段中最小的当作这条路的流量。（在图中可以反向表示，即补偿表示，表示成残存网络的形式）直到没有路可以走，总流量也就求出来了。 O(E|f*|) Edmonds-Karp算法 用广度优先搜索算法改进Ford-Fulkerson算法。 O(V$E^2$) P417 26.1-1 最大流G\u003e=G',和G\u003c=G‘来证明最大流的值相等。假设G’中存在包含该路径的最大流，那么把该路径替换，这条路也出现在G中，G的最大流肯定大于等于它。。。 多个s，再模拟一个总体的s。P417 广度优先用队列来做，一层一层的，先把儿子都找完再找孙子。 摊大饼：估计长度+真实长度。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:12:7","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"【P和NP】P616 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:13:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"P和NP p表示多项式，是Polynomial的缩写。多项式时间内可解。 NP表示在多项式时间内可以验证结果。np问题是验证性问题，如果在多项式时间内可验证，则就是np问题。 np完全问题 多项式可归约，怎么表示 什么是团问题？团是一个完全图，任意两点之间有连线。 什么是顶点覆盖问题？找一个点的集合，这个点的集合是最少的，对于图中的边，至少有一个顶点在里面。对于一个只有点没有边的图，顶点覆盖问题返回什么？返回空集。图里有很多点，任意两点都有边，顶点覆盖返回什么？返回N-1（N-2就不行啦） 什么是哈密尔顿回路问题？在一个大图中，是否存在所有点的简单回路。 NP是不是P不知道，只知道NP问题难度差不多。怎么解决，我们想到一些近似算法。 NP **若一个算法能够在多项式时间之内被验证对错，这个算法被称为NP算法。**NP问题是判定问题。 例如旅行商问题：给出一条线路，要验证是不是一条小于k的线路。验证的时候只要加和看是否小于k即可。所以旅行商问题是NP问题。 排序不是一个NP问题，排序是个动作不是一个决定/问题，问一个序列是否有序，这是个NP问题，可以在多项式时间内被验证。 所有的p问题都是np问题（在多项式时间内可解、在多项式时间内可验证），但是np问题是否为p问题，尚未被验证。 np问题有很多很多。np-complete是np问题中的一类，像TSP这种可以归约到一类的问题，目前大概有一万多种（？），都是np-complete。np-complete目前还没有被证明是不是多项式级的问题，但是可以用多项式规约为一类问题。 np-hard是对难度的衡量。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:13:1","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"几个NP问题 TSP问题 旅行商问题 高复杂度问题 假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。 目前最好的算法O($n2^n$) clique问题，clique完全图(团，每个点和其他边都相邻)，对于一个图找出里面的最大团等于几 是否在图中存在团C，使得|C|\u003eK。其实就是找图中最大的完全图。 O(n$2^n$) 对于NP问题不知道它究竟是不是P问题（究竟是不是多项式时间内可解）现在还是不确定的。 SAT问题（satisfiability problem）布尔表达式的可满足性问题 与或非表达式。看输入一串$x_i……x_n$用与或非把他们连接起来。是否存在一串$x_i……x_n$的值使得表达式为TRUE，看是否存在表达式为True的情况，看$x_i$分别要取什么值。 如果是或的关系，不用连线只要一个true就行了；相反的也不连线。最后找到一个团，就有使得整个表达式为True的值。 代入验证很方便，可以在多项式时间内验证完毕。 它是NP-complete问题。 所有问题遍历完之后有O($2^n$)的复杂度。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:13:2","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"近似算法 近似算法，就是给定一个参数$alpha$，返回的解在$alpha$和$2alpha$之间。（？） 顶点覆盖问题 可以找到一个顶点集合，所有点覆盖在里面。 如果没有边返回空集，如果是个完全图，返回N-1个结点（N-2个结点就不行了，在两个去掉的点之间连线）。 怎么解决这个问题？有一个近似算法。每次随机取一个结点，把相关的边都去掉。这样一个集合，比最优的集合，点数不超过它两倍。假设超过最优的集合的两倍了，有一个点就连不上了。（一条边连接两个点）（要涵盖一条边，两个顶点至少一个要在里面。如果都没被选中就不能被覆盖了） 小于等于最优解的两倍。 旅行商问题 做一个最小生成树，把两点之间的边double一下形成一条回路，然后它小于等于两倍的欧拉回路。欧拉回路，七桥问题，走一圈经过所有边。P655 再优化一下，经过两次的直接用一条边连接（三角不等式）。 目前最好的复杂度O($n^22^n$)。 集合覆盖问题 用最少的人，达到最好的效果，涵盖最多的功能。贪心算法，每次找最全面的人（覆盖范围最大的），把能力范围缩小，再找最全面的人，以此类推。 归约关系 已知pi问题想知道pi’问题有多难。对于输入x’经过一个函数f，放到算法pi中求解，看输出结果。若f复杂度知道，pi的复杂度又知道，那么总体的复杂度都知道了。其实就是转化。（叫多项式规约是因为f的复杂度是一个多项式） P638几个问题的归约的关系。 SAT\u003c=Clique。SAT可以归约到Clique问题。PPT上有。$x_i$和$非x_i$两个矛盾，无连线。必选，转换成找环的问题。 对于NP问题，我们一般设计近似算法把问题解决掉。 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:13:3","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":["Courses"],"content":"实验总结 1.merge sort算法和insertion sort和bubble sort 2.Strassen算法 3.堆实现优先级队列 4.计数排序（count sort） 5.随机选择算法（rand select）、选择算法（SELECT） 6.红黑树构建 7.最长公共子序列 8.动态规划 优化的二叉搜索树 9.Dynamic table 10.贪心算法 11.最小生成树 12.dijkstra 13.最大团 ","date":"2021-01-31","objectID":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/:14:0","tags":["Algorithm"],"title":"Algorithm ","uri":"/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"categories":null,"content":"CJ Lei A student major in data science and engineering. Let’s listen to some music! ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]