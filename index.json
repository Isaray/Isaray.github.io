[{"categories":["Notes","Books"],"content":"观潮","date":"2022-03-09","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["IT","History"],"title":"浪潮之巅阅读笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes","Books"],"content":"浪潮之巅阅读笔记 在两年前就曾经读过吴军老师的《数学之美》，吴军老师的学识、眼界和文字功底给我留下了深刻的印象，心中非常敬仰。在学校的课程学习中，也有三个老师都不约而同地提到过这门书，推荐作为课外读物。重读《数学之美》也该提上日程了。 不过，之前一直想读吴军老师的其他书，久闻《浪潮之巅》大名，但是图书馆里的基本几乎都被借走了，也就没有继续看下去。这次开学终于借到了《浪潮之巅》，希望能够边读边做一些笔记。 ","date":"2022-03-09","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["IT","History"],"title":"浪潮之巅阅读笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes","Books"],"content":"AT\u0026T AT\u0026T（美国电话电报公司），于1877年由亚历山大·贝尔（Alexander Bill）创建，1925年成立了著名的研发机构贝尔实验室（Bell Laboratories）。贝尔实验室有很多除了电话以外闻名于世的发明，包括射电天文望远镜、晶体管、数字交换机、计算机的Unix操作系统和C语言，发现了电子的波动性，提出了信息论，组织发射了第一颗商用通信卫星，铺设了第一条商用光纤。 1984年在反垄断法的要求下，AT\u0026T按地区划分出去7家小贝尔（Baby Bells）。 作者指出反垄断法并没有导致AT\u0026T的衰弱，利令智昏和互联网的兴起才是AT\u0026T衰弱的原因。 1995年达到AT\u0026T公司的顶峰，但是在接下来短短十年之间分崩离析。 1996年分离成AT\u0026T、朗讯和NCR三家公司。贝尔实验室也被一分为二，朗讯的那一半沿用了贝尔实验室的命长，AT\u0026T实验室后更名为香农实验室（Shannon Labs）。 AT\u0026T不断地被拆分上市，华尔街的投资者、股权持有者在短线投资上获得了巨大的利益，而公司却走向了深渊。另外加上互联网的兴起，可替代的实时通讯方式增多，而电话业务需求量变少。最后被自己分离的子公司SBC收购，后被法国的阿尔卡特并购，AT\u0026T从此消亡。为了撑高股价，朗讯在互联网泡沫经济年代借钱给各个公司来购买朗讯设备，只要设备被运出就会计入季度的销售额，后来借钱买设备的公司纷纷倒闭，应收款项全部都变成了净亏损。 一些印象深刻的话： 花旗银行的以为由20年资本管理经验的副总裁对我讲，评价一个上市公司的还坏，其实只要看哪些最优秀的人是流进这家公司的，还是流出这家公司的即可。（想到之前听朋友说的李航去了字节的消息，一查还是2017年的事） 另外，1972年，Unix操作系统和c语言诞生于贝尔实验室。距今不过50年 ","date":"2022-03-09","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["IT","History"],"title":"浪潮之巅阅读笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes","Books"],"content":"IBM 蓝色巨人IBM自1924以来屹立百年。 ","date":"2022-03-09","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["IT","History"],"title":"浪潮之巅阅读笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes","Books"],"content":"Apple 一切都围绕乔布斯这个传奇任务展开。 ","date":"2022-03-09","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["IT","History"],"title":"浪潮之巅阅读笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes"],"content":"Zotero的安装和使用","date":"2022-01-27","objectID":"/zotero/","tags":["Tools"],"title":"Zotero的使用","uri":"/zotero/"},{"categories":["Notes"],"content":"Zotero Zotero是一款开源文献管理软件，功能和EndNote相似，但是其丰富的插件使其具有十分强大的功能。 到官网（Zotero | Downloads）下载对应版本的Zotero和浏览器插件。 按照网上教程安装Zotero插件，参考连接如下： Zotero的插件介绍 - 知乎 (zhihu.com) 安装quicklook后点击空格就可以预览。 Zotero网盘同步及文件夹重命名 - 知乎 (zhihu.com) 所有文件都存储到了onedrive的文件夹下。 下载坚果云客户端，配置文件夹可以达到同样的效果。 ","date":"2022-01-27","objectID":"/zotero/:0:0","tags":["Tools"],"title":"Zotero的使用","uri":"/zotero/"},{"categories":["Tutorial"],"content":"Install Hugo on Wins and build your own website!","date":"2022-01-17","objectID":"/build_websites_with_hugo/","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Build our own website by using Hugo on Wins Hugo is said to be the world’s fastest framework for building websites. The world’s fastest framework for building websites | Hugo (gohugo.io) ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:1:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Install Hugo There are so many tutorials for installing hugo on macOS and Linux, and this blog mainly fucuses on how to install hugo on Windows. And I recommend using method two. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Method One： Using Official Docs Hugo official installation file： Install Hugo | Hugo (gohugo.io) First, make sure you have chocolatey on your laptop with Windows system. 1. Install chocolatey on Windows Chocolatey Software Docs | Setup / Install Please remember to start a command prompt as an administrator. run the following command: @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Check whether hugo is installed successfully with the following command: choco help 2.Install Hugo with Chocolatey If you are on a Windows machine and use Chocolatey for package management, you can install Hugo with the following one-liner: install-with-chocolatey.ps1 choco install hugo -confirm Or if you need the “extended” Sass/SCSS version: install-extended-with-chocolatey.ps1 choco install hugo-extended -confirm ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:1","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Method Two：Download hugo.exe directly 1.Download Hugo Releases · gohugoio/hugo (github.com) Download the certain version you need. Some website themes have requirements of hugo version. 2. Set Environment Variables Set the folder of hugo.exe as environment variables. Then, open another command line to check whether it is successfully set or not. Run the command in CMD: hugo version ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:2:2","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Themes I Prefered There are many themes on the official websites. Complete List | Hugo Themes (gohugo.io) Personally I prefered the following themes. Academic | Hugo Themes (gohugo.io) Academic | Hugo Themes (gohugo.io) PaperMod | Hugo Themes (gohugo.io) Even | Hugo Themes (gohugo.io) Tranquilpeak | Hugo Themes (gohugo.io) Clean White | Hugo Themes (gohugo.io) LoveIt | Hugo Themes (gohugo.io) I use the theme LoveIt. LoveIt (hugoloveit.com) Install it according to the official document and try to build demo yourself. Theme Documentation - Basics - LoveIt (hugoloveit.com) You can also follow the steps in this video. Although it is on the MacOS system, she explained everything clearly in Chinese. Hugo - 10分钟搭建 \u0026 部署个人网站/博客，简历中的博客网站怎么建哔哩哔哩bilibili ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:3:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Memos ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:0","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Important Command 1.hugo serve Executehugo serve under the root folder of the project, click http://localhost:1313/ to visit your website locally. 2.hugo make sure that in the config.toml , it is written like baseUrl=“https://[username].github.io” Executehugo under the root folder of the project. For the first time you do it, the public folder will be made. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:1","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Publish on GitHub Pages new a repository，setting it to public。 Set the address of your blog [username].github.io at setting/pages. Set the branch to master if you use it. Executehugo under the root folder of the project. For the first time you do it, the public folder will be made.(make sure that in the config.toml , it is written like baseUrl=“https://[username].github.io”) cd public, run the command: git init git add . git commit -m\"first commit\" git add remote origin \"your reposotory address\" git push -u origin master Wait a few minites，and you can visit your website on https://[username].github.io. tips: If the your website doesn’t change after a sucessful push, please check the actions of repository. The compiling of new github pages probably failed. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:2","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"Some mistakes I met If the style/css of the website went wrong, you should check the url and address in index.html page. Perhaps the baseUrl is wrong. ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:3","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Tutorial"],"content":"The Extended Functions of LoveIt： Hugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 - Yulin Lewis' Blog (lewky.cn) There are four blogs in the link , including the improvements of searching！ The official link is also helpful. Theme Documentation - Extended Shortcodes - LoveIt (hugoloveit.com) Save My config.toml I revise the config.toml according to the offical demo and files, including: [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"xxx\" [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"xxx\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否保持使用文章前面的静态目录 keepStatic = false [params.list] # list 页面每页显示文章数量 paginate = 10 ... Here is my config.toml I delete the function of comments, because it goes wrong on github pages. baseURL = \"https://xxx.github.io/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" title = \"xxx's blog\" # Change the default theme to be use when building the site with Hugo theme = [\"hugo-search-fuse-js\",\"LoveIt\"] # whether to use emoji code # 是否使用 emoji 代码 enableEmoji = true [menu] [[menu.main]] identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"projects\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Projects\" url = \"/categories/projects/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [[menu.main]] identifier = \"about\" pre = \"\" post = \"\" name = \"About\" url = \"/about/\" title = \"\" weight = 5 [[menu.main]] pre = \"\u003ci class='fas fa-fw fa-search'\u003e\u003c/i\u003e\" name = \"search\" weight = 7 identifier = \"search\" url = \"/search/\" [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = false # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Isaray's blog\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 ","date":"2022-01-17","objectID":"/build_websites_with_hugo/:4:4","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?","uri":"/build_websites_with_hugo/"},{"categories":["Notes"],"content":"递归、分治、贪心、回溯、动态规划和枚举","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.递归 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.1算法策略 把问题分解成更小规模的同类子问题，用递归调用的方法求解问题。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.2 适用场景 引用知乎一篇文章的总结 递归算法一般用于解决三类问题： 数据的定义是按递归定义的。（斐波那契数列） 问题解法按递归算法实现。（回溯） 数据的结构形式是按递归定义的。（树的遍历，图的搜索） 解题策略 （1）明确输入输出 （2）明确递归结束条件 （3）明确递归关系式 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.3经典问题 斐波那契数列 汉诺塔问题 树的遍历及相关操作 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:1:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.分治 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.1算法策略 将一个问题分解成多个子问题，每个子问题又可以分解成更小的子问题，直到子问题可以被求解。原问题是子问题的合并。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.2适用场景 当出现满足以下条件的问题，可以尝试只用分治策略进行求解： 原始问题可以分成多个相似的子问题 子问题可以很简单的求解 原始问题的解是子问题解的合并 各个子问题是相互独立的，不包含相同的子问题 解题策略 分解大问题 解决子问题 合并子问题结果 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.3经典问题 二分查找 归并排序 快速排序 汉诺塔问题 React 时间分片 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:2:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.贪心 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.1算法策略 总是选择当下最优的解决方案。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.2适用场景 当满足一下条件时，可以使用： 原问题复杂度过高 求全局最优解的数学模型难以建立或计算量过大 没有太大必要一定要求出全局最优解，“比较优”就可以 解题策略 定义最优解条件 把问题分解成多个步骤，每一步要满足 可行性：每一步都满足问题的约束 局部最优 不可取消 最后叠加所有步骤得到最优解。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.3经典问题 使用贪心算法求解的经典问题有： 最小生成树算法 单源最短路径的 Dijkstra 算法 Huffman 压缩编码 背包问题 活动选择问题等 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:3:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.回溯 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.1算法策略 步步尝试，不行回退。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.2适用场景 不断的尝试，直到拿到解。从一组可能的解中，选择一个满足要求的解。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"4.3经典问题 深度优先搜索 0-1背包问题 正则表达式匹配 八皇后 数独 全排列 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:4:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.动态规划 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.1算法策略 Taking notes. 将复杂问题分解成小问题求解，各个子问题之间有重合，结果可以复用。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.2适用场景 求解最优解。 解题策略 需要遵循以下几个重要步骤： 定义子问题 实现需要反复执行解决的子子问题部分 识别并求解出边界条件 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"5.3经典问题 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现） ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:5:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.枚举 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:0","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.1算法策略 一一列举，明确列举范围。 ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:1","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"6.3经典问题 参考： 95% 的算法都是基于这 6 种算法思想！！！ - 知乎 (zhihu.com) BAT机器学习面试1000题系列_HuangQinJian-CSDN博客_bat机器学习1000题 剑指offer-Python版（上） - 知乎 (zhihu.com) ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:2","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"1.bfs,dfs dfs可以看作不知道层数情况下的枚举法，用到递归的思想。 回溯算法，先列举出来再还原。 全排列 class Solution2: def permute(self, nums: List[int]) -\u003e List[List[int]]: res = [] def backtrack(nums, tmp): if not nums: res.append(tmp) return for i in range(len(nums)): backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]]) backtrack(nums, []) return res 岛屿数量 class Solution: def numIslands(self, grid): row, col, ret = len(grid), len(grid[0]), 0 def dfs(x, y): grid[x][y] = '0' for c in [[0, 1], [0, -1], [1, 0], [-1, 0]]: nx, ny = x + c[0], y + c[1] if 0 \u003c= nx \u003c row and 0 \u003c= ny \u003c col and grid[nx][ny] == '1': dfs(nx, ny) for i in range(row): for j in range(col): if grid[i][j] == '1': dfs(i, j) ret += 1 return ret ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:3","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"2.binary search 求x的平方根 class Solution: def mySqrt(self, x: int) -\u003e int: l, r, ans = 0, x, -1 while l \u003c= r: mid = (l + r) // 2 if mid * mid \u003c= x: ans = mid l = mid + 1 else: r = mid - 1 return ans ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:4","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Notes"],"content":"3.sliding window move them simutanously 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。 示例 1: 输入: s = “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 class Solution: def lengthOfLongestSubstring(self, s: str) -\u003e int: cur, res = [], 0 for r in range(len(s)): while s[r] in cur: cur.pop(0) # 左边出 cur.append(s[r]) # 右侧无论如何都会进入新的 res = max(len(cur),res) return res recursion fibonacci, binary tree class Solution: def hanota(self, A: List[int], B: List[int], C: List[int]) -\u003e None: \"\"\" Do not return anything, modify C in-place instead. \"\"\" n = len(A) self.move(n, A, B, C) def move(self, n, A, B, C): if n == 1: C.append(A.pop()) else: self.move(n-1, A, C, B) C.append(A.pop()) self.move(n-1, B, A, C) inverting into binary tree reverse a linked list class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 申请两个节点，pre和 cur，pre指向None pre = None cur = head # 遍历链表，while循环里面的内容其实可以写成一行 # 这里只做演示，就不搞那么骚气的写法了 while cur: # 记录当前节点的下一个节点 tmp = cur.next # 然后将当前节点指向pre cur.next = pre # pre和cur节点都前进一位 pre = cur cur = tmp return pre suffix trees class Trie: def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix: str) -\u003e \"Trie\": node = self for ch in prefix: ch = ord(ch) - ord(\"a\") if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word: str) -\u003e None: node = self for ch in word: ch = ord(ch) - ord(\"a\") if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word: str) -\u003e bool: node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix: str) -\u003e bool: return self.searchPrefix(prefix) is not None heaps repeatedly find min,max 第 k 个最大的元素 class Solution: def findKthLargest(self, nums: List[int], k: int) -\u003e int: # 构造大小为 k 的小顶堆 heap = [x for x in nums[:k]] heapq.heapify(heap) n = len(nums) for i in range(k, n): if nums[i] \u003e heap[0]: heapq.heappop(heap) heapq.heappush(heap, nums[i]) return heap[0] dynamic programming sorting algorithm quick sort and merge sort ","date":"2022-01-17","objectID":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/:6:5","tags":["Python","Algorithm"],"title":"六种常见算法","uri":"/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"categories":["Experiments"],"content":"How to draw the memory mountain? ","date":"2021-01-31","objectID":"/csapp-memory_mountain/","tags":["CSAPP","Courses"],"title":"CSAPP:memory mountain","uri":"/csapp-memory_mountain/"},{"categories":["Experiments"],"content":"CSAPP:memory mountain 画memory mountain存储器山： https://blog.csdn.net/weixin_41724000/article/details/100072251 http://csapp.cs.cmu.edu/3e/students.html /* mountain.c - Generate the memory mountain. */ /* $begin mountainmain */ #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \"fcyc2.h\" /* measurement routines */#include \"clock.h\" /* routines to access the cycle counter */ #define MINBYTES (1 \u003c\u003c 14) /* First working set size */#define MAXBYTES (1 \u003c\u003c 27) /* Last working set size */#define MAXSTRIDE 15 /* Stride x8 bytes */#define MAXELEMS MAXBYTES/sizeof(long) /* $begin mountainfuns */ long data[MAXELEMS]; /* The global array we'll be traversing */ /* $end mountainfuns */ /* $end mountainmain */ void init_data(long *data, int n); int test(int elems, int stride); double run(int size, int stride, double Mhz); /* $begin mountainmain */ int main() { int size; /* Working set size (in bytes) */ int stride; /* Stride (in array elements) */ double Mhz; /* Clock frequency */ init_data(data, MAXELEMS); /* Initialize each element in data */ Mhz = mhz(0); /* Estimate the clock frequency */ /* $end mountainmain */ /* Not shown in the text */ printf(\"Clock frequency is approx. %.1f MHz\\n\", Mhz); printf(\"Memory mountain (MB/sec)\\n\"); printf(\"\\t\"); for (stride = 1; stride \u003c= MAXSTRIDE; stride++) printf(\"s%d\\t\", stride); printf(\"\\n\"); /* $begin mountainmain */ for (size = MAXBYTES; size \u003e= MINBYTES; size \u003e\u003e= 1) { /* $end mountainmain */ /* Not shown in the text */ if (size \u003e (1 \u003c\u003c 20)) printf(\"%dm\\t\", size / (1 \u003c\u003c 20)); else printf(\"%dk\\t\", size / 1024); /* $begin mountainmain */ for (stride = 1; stride \u003c= MAXSTRIDE; stride++) { printf(\"%.0f\\t\", run(size, stride, Mhz)); } printf(\"\\n\"); } exit(0); } /* $end mountainmain */ /* init_data - initializes the array */ void init_data(long *data, int n) { int i; for (i = 0; i \u003c n; i++) data[i] = i; } /* $begin mountainfuns */ /* test - Iterate over first \"elems\" elements of array \"data\" with * stride of \"stride\", using 4x4 loop unrolling. */ int test(int elems, int stride) { long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4; long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0; long length = elems; long limit = length - sx4; /* Combine 4 elements at a time */ for (i = 0; i \u003c limit; i += sx4) { acc0 = acc0 + data[i]; acc1 = acc1 + data[i+stride]; acc2 = acc2 + data[i+sx2]; acc3 = acc3 + data[i+sx3]; } /* Finish any remaining elements */ for (; i \u003c length; i++) { acc0 = acc0 + data[i]; } return ((acc0 + acc1) + (acc2 + acc3)); } /* run - Run test(elems, stride) and return read throughput (MB/s). * \"size\" is in bytes, \"stride\" is in array elements, and Mhz is * CPU clock frequency in Mhz. */ double run(int size, int stride, double Mhz) { double cycles; int elems = size / sizeof(double); test(elems, stride); /* Warm up the cache */ //line:mem:warmup cycles = fcyc2(test, elems, stride, 0); /* Call test(elems,stride) */ //line:mem:fcyc return (size / stride) / (cycles / Mhz); /* Convert cycles to MB/s */ //line:mem:bwcompute } /* $end mountainfuns */ ","date":"2021-01-31","objectID":"/csapp-memory_mountain/:0:0","tags":["CSAPP","Courses"],"title":"CSAPP:memory mountain","uri":"/csapp-memory_mountain/"},{"categories":["Experiments"],"content":"How to solve the shlab? ","date":"2021-01-31","objectID":"/csapp-shlab/","tags":["CSAPP","Courses"],"title":"CSAPP:shlab","uri":"/csapp-shlab/"},{"categories":["Experiments"],"content":"CSAPP:shlab 该实验对应CSAPP第8章：异常控制流，可以先温习该章内容再做实验。 通读实验指南，了解实验目的： 简介 The purpose of this assignment is to become more familiar with the concepts of process control and signalling. You’ll do this by writing a simple Unix shell program that supports job control. 本实验的目的就是写一个简单的Unix shell，主要任务就是修改tsh.c文件，需修改以下7个函数。 1.void eval(char *cmdline); //解释命令[70 lines] 2.int builtin_cmd(char **argv);//识别命令是否为内置命令quit、jobs、fg、bg ，若是，则执行对应命令.[25 lines] quit命令会终止shell。 jobs 命令列出所有后台工作。 bg 命令通过发送一个 SIGCONT 信号重新启动，然后在后台运行。参数可以是 PID 或 JID。 fg 命令通过发送一个 SIGCONT 信号重新启动，然后在前台运行。 3.void do_bgfg(char **argv);//执行bg,fg操作[50 lines] 4.void waitfg(pid_t pid);//等待前台操作完成 [20 lines] 5.void sigchld_handler(int sig);//抓住 SIGCHILD [信号80 lines] 6.void sigtstp_handler(int sig);//抓住 SIGINT (ctrl-c) 信号[15 lines] 7.void sigint_handler(int sig);//抓住 SIGTSTP (ctrl-z) 信号[15 lines] 关于你输入的命令： 如果第一个词是内置的命令，shell会在当前进程中立即执行该命令，否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。 如果命令行以\"\u0026“结尾，则作业在后台运行，这意味着shell在打印提示符和等待下一行命令前，不会等待job结束。否则，job在前台运行，这意味着shell在等待下一个命令行之前会等待job终止。因此，在任何时间点上，最多只能有一个job在前台运行。但是，可以有任意数量的job在后台运行。 下面一段说明很好地解释了main中的参数argc、argv代表什么意思（这里环境的参数被省略了）： Typing the command line tsh\u003e /bin/ls -l -d runs the ls program in the foreground. By convention, the shell ensures that when the program begins executing its main routine int main(int argc, char *argv[]) the argc and argv arguments have the following values: • argc == 3, • argv[0] == ‘‘/bin/ls’’, • argv[1]== ‘‘-l’’, • argv[2]== ‘‘-d’’. argc指的是参数个数，argv是指针数组，每个指针指向一个参数字符串。 一些注意事项： 如果命令行以＆结束，则tsh应该在后台运行job。 否则，它将在前台运行该job。 每个作业都可以由进程ID（PID）或作业ID（JID）标识，该ID是tsh分配的正整数。 JID应该在命令行上以前缀“％”表示。 例如，“％5”表示JID 5，“ 5”表示PID5。 tsh应该管理回收（reap）所有的僵尸子进程。 如果任何job由于接收到未捕获到的信号而终止，则tsh应该识别此事件并打印一条带有该job的PID的消息以及对该问题的信号的描述。 job Id 和 process id 是有区别的，前者需要以%为前缀，后者为一个数字。这一点在处理bg、fg指令时尤为重要 在eval中一定要 在fork子进程前用sigprocmask阻塞SIGCHLD信号；fork之后解除该阻塞 在加子进程到joblist前调用sigprocmask阻塞全部信号 因为子进程会从父进程处继承阻塞信息，所以在execve其他二进制文件前，一定要解除信号阻塞 子进程按照建议应该在 sigchld_handler被收割（reap），所以父进程需要在调用addjob之前阻塞SIGCHLD信号，以防止竞态条件 当在标准unix shell中运行tsh程序时，从tsh程序fork出来的子程序会和tsh处于同一个process group；因此你需要使用setpgid来重置子进程process group id；如若不然，在ctrl-c \u0026 ctrl-z的处理上会有一些问题 用sigprocmask阻塞信号，因为有时候不希望在接到信号时就立即停止当前执行，去处理信号，同时也不希望忽略该信号，而是延时一段时间去调用信号处理函数。 检验结果用到的一些命令 先make 共16组测试数据，test结果要和rtest完全一样才算通过。 make test01 相当于 ./sdriver.pl -t trace01.txt -s ./tsh -a \"-p\" make rtest01 相当于 ./sdriver.pl -t trace01.txt -s ./tshref -a \"-p\" 实验代码和注释 eval eval解析输入的命令： 如果第一个词是内置的命令builtin_cmd(argv)，shell会在当前进程中立即执行该命令。 否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。 注意：在创建子进程前要阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，导致信号丢失，所以在fork子进程前阻塞sigchld信号，并在fork,addjob后解除 /* * eval - Evaluate the command line that the user has just typed in * * If the user has requested a built-in command (quit, jobs, bg or fg) * then execute it immediately. Otherwise, fork a child process and * run the job in the context of the child. If the job is running in * the foreground, wait for it to terminate and then return. Note: * each child process must have a unique process group ID so that our * background children don't receive SIGINT (SIGTSTP) from the kernel * when we type ctrl-c (ctrl-z) at the keyboard. */ void eval(char *cmdline) { // static char array[MAXLINE]; /* holds local copy of command line */ // char *buf = array; /* ptr that traverses command line */ char *argv[MAXARGS]; //命令行参数 pid_t pid; //子进程PID int bg; // 最后是否是\u0026，即是否后台执行， sigset_t mask_one, prev, mask_all; // strcpy(buf, cmdline); //缓存命令行 bg = parseline(cmdline, argv); if(argv[0] == NULL) return;//忽略空行 if(!builtin_cmd(argv)){//如果不是shell的内嵌命令 sigemptyset(\u0026mask_one);//初始化信号量集 sigaddset(\u0026mask_one, SIGCHLD);//将SIGCHLD添加到信号量集中 sigfillset(\u0026mask_all);// 设置全阻塞 sigprocmask(SIG_BLOCK, \u0026mask_one, \u0026prev);//阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，所以在fork子进程前阻塞sigchld信号，addjob后解除 if((pid = fork()) == 0){ // 子进程继承了父进程的阻塞向量，也要解除阻塞，避免收不到它本身的子进程的信号 setpgid(0, 0); //把pid=0放到gpid=0的进程组 sigprocmask(SIG_SETMASK, \u0026prev, NULL);//恢复被屏蔽的信号，防止遗漏 //容错 if(execve(argv[0], argv, environ) \u003c 0){ ","date":"2021-01-31","objectID":"/csapp-shlab/:0:0","tags":["CSAPP","Courses"],"title":"CSAPP:shlab","uri":"/csapp-shlab/"},{"categories":["Experiments"],"content":"How to solve the malloclab? ","date":"2021-01-31","objectID":"/csapp-malloclab/","tags":["CSAPP","Courses"],"title":"CSAPP:malloclab","uri":"/csapp-malloclab/"},{"categories":["Experiments"],"content":"CSAPP:malloclab CSAPP:9.9.12 针对空闲块的组织方法有以下三种： a.隐式空闲链表(implicit free list) b.显式空闲链表(explicit free list) c.分离空闲链表(segregated free list) 查找空闲块的三个方法： a.首次适应(first fit) b.最佳适配(best fit) c.下一次适配(next fit) d.分离适配，特殊情况包括伙伴系统，优点在于快速搜索和快速合并（大小相同，地址连续）。 方案一：隐式空闲链表+first fit/next fit 初始化堆 —— mm_init函数 mm_init步骤如下： 首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。 调extend_heap扩展堆，创建初始的空闲块，大小为4096字节。 扩展堆 —— extend_heap函数 函数原型: static void *extend_heap(size_t words); 以下两种场景需要扩展堆： 调用mm_init初始化堆时。 调用mm_malloc找不到合适的空闲块时。 释放和合并块 —— mm_free和coalesce函数 调用mm_free释放块，步骤如下： 将当前块的头部和脚部中的分配位清零。 将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。 调用coalesce合并前后的合并块，原型：static void *coalesce(void *bp);，分四种情况： 情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。 情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp 情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp) 情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp) https://blog.csdn.net/pcj_888/article/details/108812886 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cassert.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e #include \"mm.h\"#include \"memlib.h\" /********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * provide your team information in the following struct. ********************************************************/ team_t team = { /* Team name */ \"ateam\", /* First member's full name */ \"Harry Bovik\", /* First member's email address */ \"bovik@cs.cmu.edu\", /* Second member's full name (leave blank if none) */ \"\", /* Second member's email address (leave blank if none) */ \"\" }; static char *heap_listp; #define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1\u003c\u003c12) /* Extend heap by this amount (bytes) */ #define MAX(x, y) ((x) \u003e (y) ? (x) : (y)) /* Pack a size and allocated bit into word */ #define PACK(size, alloc) ((size) | (alloc)) /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) #define PUT(p, val) (*(unsigned int *)(p) = (val)) /* Read the size and allocated fields from address p */ #define GET_SIZE(p) (GET(p) \u0026 ~0x7) #define GET_ALLOC(p) (GET(p) \u0026 0x1)// 判断这个块是否已分配 /* Given block ptr bp, compute address of its header and footer */ #define HDRP(bp) ((char *)(bp) - WSIZE) #define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) /* Given block ptr bp, compute address of next and previous blocks */ #define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) #define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) /* Globe var */ static char *heap_listp; /* 函数声明 */ static void *extend_heap(size_t words); static void *coalesce(void *bp); static void *find_fit(size_t asize); /* single word (4) or double word (8) alignment */ #define ALIGNMENT 8 /* rounds up to the nearest multiple of ALIGNMENT */ #define ALIGN(size) (((size) + (ALIGNMENT-1)) \u0026 ~0x7) #define SIZE_T_SIZE (ALIGN(sizeof(size_t))) /* * mm_init - initialize the malloc package. */ int mm_init(void) { if((heap_listp=mem_sbrk(4*WSIZE))==(void*)-1) return -1; PUT(heap_listp,0); PUT(heap_listp+(1*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(2*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(3*WSIZE),PACK(0,1)); heap_listp+=(2*WSIZE); if(extend_heap(CHUNKSIZE/WSIZE)==NULL) return -1; return 0; } static void *extend_heap(size_t words){ char *bp; size_t size; size=(words%2)? ((words+1) *WSIZE):(words*WSIZE); if((long)(bp=mem_sbrk(size))==-1) return NULL; PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(NEXT_BLKP(bp)),PACK(0,1)); return coalesce(bp); } void place(void *bp,size_t asize){ size_t csize=GET_SIZE(HDRP(bp)); //若剩下的空间比2*DSIZE占的空间大，那么就分割它 if((csize-asize)\u003e=(2*DSIZE)){ PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); bp=NEXT_BLKP(bp); PUT(HDRP(bp),PACK(csize-asize,0)); PUT(FTRP(bp),PACK(csize-asize,0)); } else{ PUT(HDRP(bp),PACK(csize,1)); PUT(FTRP(bp),PACK(csize,1)); } } /* * mm_malloc - Allocate a block by incrementing the brk pointer. * Always allocate a block whose size is a multipl","date":"2021-01-31","objectID":"/csapp-malloclab/:0:0","tags":["CSAPP","Courses"],"title":"CSAPP:malloclab","uri":"/csapp-malloclab/"},{"categories":["Experiments"],"content":"How to solve the bomblab? bomb!!","date":"2021-01-31","objectID":"/csapp-bomblab/","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab","uri":"/csapp-bomblab/"},{"categories":["Experiments"],"content":"CSAPP:bomblab ","date":"2021-01-31","objectID":"/csapp-bomblab/:0:0","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab","uri":"/csapp-bomblab/"},{"categories":["Experiments"],"content":"Bomblab拆弹实录 ","date":"2021-01-31","objectID":"/csapp-bomblab/:1:0","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab","uri":"/csapp-bomblab/"},{"categories":["Experiments"],"content":"准备工作 调试环境： 云主机Linux环境+GDB ssh客户端： xshell+xftp/putty+psftp xshell+xftp:上传和下载文件有可视化操作界面，直接拖拽就可以上传。但是在gdb调试的时候，输入了的数据不能修改，按回车会输入^H，有的时候会手误就要重新开始。 putty+psftp：上传文件用scp命令（例如：scp hello.c xx@xxx.75.241.219/home/xx/lab0；scp -r 拷贝目录），下载文件可以用psftp。假设要下载到本地目录E:,在psftp中运行lcd E:\\定位本地目录，putty切换到云主机目录之后，get 文件名即可下载。 Linux相关命令 ： cd document切换到文件夹; cd ..返回上一级目录;ls显示文件夹中的文件;pwd当前目录位置 解压:tar -xf all.tar，tar -zxvf filename.tar.gz cat filename 显示文件内容 vim filename查看/编辑文件内容，i进入编辑模式，esc退出编辑模式，:wq保存并退出，:q没修改直接退出。 复制文件：cp document/file newdocument/newfile 重命名：mv oldname newname GDB调试： 进入GDB调试状态，gdb filename;或先运行gdb再运行file filename info b看断点情况；b(reak) 行号/函数名 打断点；d (elete) 行号/函数名 删除断点 i r看寄存器的值。info reg esp看%esp里存储了什么。print $eax。print (char*) $ebx。 x/s 0xffff5330 打印该地址存储的字符串；x/16x 地址 答应之后16个字节的数字。 s单步执行（不会进入被调用的函数内部），si单步执行（会进入被调用的函数内部）。c接着运行到下一个断点。 display /ni $pc。用si调试每行都会显示下一行的汇编语言。 ","date":"2021-01-31","objectID":"/csapp-bomblab/:1:1","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab","uri":"/csapp-bomblab/"},{"categories":["Experiments"],"content":"题目求解 phase_1:地址字符串 比较字符串是否相等，查看地址中预设的字符串即可。 phase_2:循环 读入六个数字做判断，读懂汇编语言，知道后一个数等于前两个数的加和即可。 phase_3:switch \u003c7 每个数对应一个值 是一个switch函数，输入1-7会跳转到不同的地址，和事先存入的数字进行比较。有多个答案。 phase_4: 递归调用了func4()。首先输入的数字小于等于4。输入4，之后经过递归调用该函数得到216，最后和输入的第一个数字进行比较，所以第一个数字为216，第二个数字为4。应该有不同的答案。 // int func4(edi ,esi,ebx){//edi last,ebx last %ebx=0x10(%esp) //8 //变成上次的eax，即7 %edi=0x14(%esp) //第二个参数 if ebx== 0 then return 0; eax=edi if ebx==1 then return eax eax=ebx-1. 从头递归。 esi=edi+eax ebx=ebx-2 从头递归。 eax=eax+esi return eax } phase_5: %ebx存放字符串。 x/100x 0x804a040 看这个地址之后存放了什么。理解地址代表的含义是关键。每个输入的字符取十六进制ASCII码的后一位*4+该地址，找到对应的数字，累加到%ecx。最后%ecx要等于41。反推出要输入的字母。 0:02;1:a;2:6;3:1;4:c;5:0x10;6:9;7:3;8:4;9:7;10:e;11:5;12:b;13:8;14:f;15:d Prstux 2+6+1+12+16+4=41 phase_6: 读入6个数字，六个数字都\u003c=6，六个数字互不相等。程序里事先存储了6个节点，六个节点有各自的编号，最后要从小到大输出，否则就爆炸。输入的6个数字代表，节点从小到大排列的顺序。 phase_6太长了，理解了好久，做到最后还挺崩溃的，只能说大胆假设，小心求证。理解地址代表的含义同样是关键，看到node要发挥想象力。 5 3 2 1 4 6 0x1d5 0x325 0x391 0x1c6 0x3a5 0xef secret_phase: secret phase要触发，首先要在phase_4处多输入一个字符串DrEvil。 首先输入的数字要小于等于1000，然后secret调用func7()，经过func7()之后必须为0。传入一个地址0x804c088，查看它就可以解开题目中预先存储的数据。整个条件判断类似二叉树的结构，要和根节点的值一致且要执行到末端，否则返回-1。又是递归。 这只是简要版解题思路，图片后续再补~ 解开一个要缓一缓，然后发现跟后一个phase比起来，前一个简直是小case。发现做到最后最重要的其实是心态。 最后，有高级语言真好。 ","date":"2021-01-31","objectID":"/csapp-bomblab/:1:2","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab","uri":"/csapp-bomblab/"},{"categories":["Experiments"],"content":"How to solve datalab?","date":"2021-01-31","objectID":"/csapp-datalab/","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"CSAPP:datalab 代码中有具体思路的标注。 以下为实验的说明，每道题目中有规定一些运算符能否使用，使用的符号个数，并规定一些控制结构和函数不能使用。 /* * CS:APP Data Lab * * * bits.c - Source file with your solutions to the Lab. * This is the file you will hand in to your instructor. * * WARNING: Do not include the \u003cstdio.h\u003e header; it confuses the dlc * compiler. You can still use printf for debugging without including * \u003cstdio.h\u003e, although you might get a compiler warning. In general, * it's not good practice to ignore compiler warnings, but in this * case it's OK. */ #if 0Each \"Expr\" is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations \u0026 ^ | + \u003c\u003c \u003e\u003e Some of the problems restrict the set of allowed operators even further. Each \"Expr\" may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as \u0026\u0026, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting an integer by more than the word size. EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 \u003c= x \u003c= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 \u003c\u003c x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 \u003c= x \u003c= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 \u003c\u003c x); result += 4; return result; } FLOATING POINT CODING RULES For the problems that require you to implent floating-point operations, the coding rules are less strict. You are allowed to use looping and conditional control. You are allowed to use both ints and unsigneds. You can use arbitrary integer and unsigned constants. You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants. NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operators (! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that '=' is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source. 以下为所需要写的函数，每个函数的说明和限制都在注释中有具体讲解。 ","date":"2021-01-31","objectID":"/csapp-datalab/:0:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"1.bitAnd ： 不用\u0026，而用|表示\u0026。两者像照镜子，\u0026是同1则1，|是同0则0，用德摩根律，一反再反刚好对称过来。 /* * bitAnd - x\u0026y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */ int bitAnd(int x, int y) { /*It's equal to find the position that both are 0 and find its reversed version.有点像德摩根律。*/ return ~(~x|~y); } ","date":"2021-01-31","objectID":"/csapp-datalab/:1:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"2.getByte: 先算数左移再算数右移，再减去算数右移增加的补位数 /* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 6 * Rating: 2 */ int getByte(int x, int n) { /*先算数左移再算数右移，再减去算数右移增加的补位数*/ int t,t1,t2; t1=x\u003c\u003c((3-n)*2*4); t2=t1\u003e\u003e7*4\u003e\u003e4\u003c\u003c(2*4); t=(t1\u003e\u003e(6*4))-t2; return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:2:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"3.logicalShift: 找出最高位的符号，然后把算数右移前面补的位数减掉即可 ~n+1相当于-n 0xffffffff相当于-1 /* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 \u003c= n \u003c= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 20 * Rating: 3 */ int logicalShift(int x, int n) { /*找出最高位的符号，然后把算数右移前面补的位数减掉即可*/ int t; t=x\u003e\u003e31\u003c\u003c(32+(~n+1)+0xffffffff)\u003c\u003c1; t=(x\u003e\u003en)\u0026(~t); //这里用了一个mask小技巧，\u0026mask为1的位置就会显露出来 return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:3:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"4.bitCount: 原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！ /* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 40 * Rating: 4 */ int bitCount(int x) { /*difficult*/ /*原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！*/ int mask1=0x55555555;//01(循环至32位)01010101 int mask2=0x33333333;//0011(循环至32位) int mask3=0x0f0f0f0f;//00001111(循环至32位) int mask4=0x00ff00ff;//0000000011111111(循环至32位) int mask5=0x0000ffff;//00000000000000001111111111111111 int t; t=(x\u0026mask1)+((x\u003e\u003e1)\u0026mask1); t=(t\u0026mask2)+((t\u003e\u003e2)\u0026mask2); t=(t\u0026mask3)+((t\u003e\u003e4)\u0026mask3); t=(t\u0026mask4)+((t\u003e\u003e8)\u0026mask4); t=(t\u0026mask5)+((t\u003e\u003e16)\u0026mask5); return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:4:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"5.bang: 利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。 /* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int bang(int x) { /*利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。*/ return ((x|(~x+1))\u003e\u003e31)+1 ; } ","date":"2021-01-31","objectID":"/csapp-datalab/:5:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"6.tmin: 很简单。根据定义即可。 /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1\u003c\u003c31; } ","date":"2021-01-31","objectID":"/csapp-datalab/:6:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"7.fitsBits: 就是用两种不同方式去解读，判断能不能表示成n位有符号数。 第n位和第n位之前的位数的数字应该都相同，否则就无法表示。判断是否相同用按位与的方式。 /* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 \u003c= n \u003c= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 2 */ int fitsBits(int x, int n) { /*第n位和第n位之前的位数的数字应该都相同，否则就无法表示。*/ return !((x\u003c\u003c(32-n)\u003e\u003e(32-n))^x); } ","date":"2021-01-31","objectID":"/csapp-datalab/:7:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"8.divpwr2: 非整除情况，如果是负数的话，x»n结果要加一(n非0)。对于对于负数~(x»31)=0。整除情况如常。 /* * divpwr2 - Compute x/(2^n), for 0 \u003c= n \u003c= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 2 */ int divpwr2(int x, int n) { /*非整除情况，如果是负数的话，x\u003e\u003en结果要加一(n非0)。对于对于负数~(x\u003e\u003e31)=0。整除情况如常。*/ int s=!!(x\u003e\u003e31); int t=!!((x\u003c\u003c(32+~n+1))^0); return (x\u003e\u003en)+(s\u0026t\u0026!!n); } ","date":"2021-01-31","objectID":"/csapp-datalab/:8:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"9.negate: 因为 ~x+x=0xffffffff且0xffffffff=-1。所以-x= ~x+1。 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; } ","date":"2021-01-31","objectID":"/csapp-datalab/:9:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"10.isPositive: x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。 /* * isPositive - return 1 if x \u003e 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 8 * Rating: 3 */ int isPositive(int x) { /*x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。*/ return !(x\u003e\u003e31)\u0026!!x; } ","date":"2021-01-31","objectID":"/csapp-datalab/:10:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"11.isLessOrEqual: 即y-x\u003e=0或y\u003e0,x\u003c0(若溢出)。分类讨论。（y\u003e0,x\u003e0,y-x\u003e0）|（y\u003e0,x\u003c0）|（y\u003c0,x\u003c0,y-x\u003e0） /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { /*即y-x\u003e=0或y\u003e0,x\u003c0(若溢出)。分类讨论。*/ return (!(y\u003e\u003e31)\u0026!(x\u003e\u003e31)\u0026!((y+~x+1)\u003e\u003e31))|((!(y\u003e\u003e31))\u0026(x\u003e\u003e31))|((y\u003e\u003e31)\u0026(x\u003e\u003e31)\u0026!((y+~x+1)\u003e\u003e31)); } ","date":"2021-01-31","objectID":"/csapp-datalab/:11:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"12.ilog2: 找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！ /* * ilog2 - return floor(log base 2 of x), where x \u003e 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int ilog2(int x) { /*找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！*/ int t; t=(!!(x\u003e\u003e16))\u003c\u003c4; t=t+((!!(x\u003e\u003e(8+t)))\u003c\u003c3); t=t+((!!(x\u003e\u003e(4+t)))\u003c\u003c2); t=t+((!!(x\u003e\u003e(2+t)))\u003c\u003c1); t=t+(!!(x\u003e\u003e(1+t))); return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:12:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"13.float_neg: 判断是否为NaN，然后最高位取反。 /* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 10 * Rating: 2 */ unsigned float_neg(unsigned uf) { /*判断是否为NaN，然后最高位取反。*/ unsigned exp=(uf\u00260x7ff80000)\u003e\u003e23;//011111111100000000000000000000000 unsigned frac=uf\u00260x7fffff;//00000000011111111111111111111111 if(!(exp^0xff) \u0026\u0026 !!(frac^0) )//exp=0xff且frac!=0 return uf;//为NaN返回NaN return uf^0x80000000;//s位变号即可 } ","date":"2021-01-31","objectID":"/csapp-datalab/:13:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"14.float_i2f: 主要看次数+要不要进位 32-i-1+127即exp flag是看要不要进位 /* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned i=0,t; unsigned s=(!!(x\u003e\u003e31))\u003c\u003c31; if(!(x^0)) return 0;//为0则0 if(!(x^0x80000000)) return 0xcf000000;//-2^31 if(s) x=~x+1;//负数转换成正数 while(!((x\u003c\u003ci)\u00260x80000000)){//高位不为1就循环 i=i+1; } t=(x\u003c\u003ci)-0x80000000; int flag=0;//若进位，flag变成1 if((t\u00260xff)\u003e0x80) flag=1; else{ if((t\u00260x180)==0x180) flag=1; } t=t\u003e\u003e8; t=s+((32-i-1+127)\u003c\u003c23)+t+flag;//32-i-1+127即exp return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:14:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"15.float_twice: denormalized 的浮点数,exp全为0，乘以2只需将frac左移一位并保持符号不变 normalized 的浮点数，乘以2只需exp++ /* float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { unsigned exp=(uf\u00260x7ff80000)\u003e\u003e23;//011111111100000000000000000000000 unsigned frac=uf\u00260x7fffff;//00000000011111111111111111111111 unsigned t; if(!(exp^0xff) ){ return uf;//NaN } int k=!!(uf\u00260x7fffffff)\u0026!!exp; t=(uf\u00260x80000000)+((exp+k)\u003c\u003c23)+(frac\u003c\u003c!exp);//s+exp+frac//exp全0的，frac\u003c\u003c1,exp不变;否则exp++ return t; } ","date":"2021-01-31","objectID":"/csapp-datalab/:15:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":["Experiments"],"content":"结果： ./btest ","date":"2021-01-31","objectID":"/csapp-datalab/:16:0","tags":["CSAPP","Courses"],"title":"CSAPP:datalab","uri":"/csapp-datalab/"},{"categories":null,"content":"CJ Lei A student major in data science and engineering. Let’s listen to some music! ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]