[{"categories":["Notes","Books"],"contents":"浪潮之巅阅读笔记 在两年前就曾经读过吴军老师的《数学之美》，吴军老师的学识、眼界和文字功底给我留下了深刻的印象，心中非常敬仰。在学校的课程学习中，也有三个老师都不约而同地提到过这门书，推荐作为课外读物。重读《数学之美》也该提上日程了。\n不过，之前一直想读吴军老师的其他书，久闻《浪潮之巅》大名，但是图书馆里的基本几乎都被借走了，也就没有继续看下去。这次开学终于借到了《浪潮之巅》，希望能够边读边做一些笔记。\nAT\u0026amp;T AT\u0026amp;T（美国电话电报公司），于1877年由亚历山大·贝尔（Alexander Bill）创建，1925年成立了著名的研发机构贝尔实验室（Bell Laboratories）。贝尔实验室有很多除了电话以外闻名于世的发明，包括射电天文望远镜、晶体管、数字交换机、计算机的Unix操作系统和C语言，发现了电子的波动性，提出了信息论，组织发射了第一颗商用通信卫星，铺设了第一条商用光纤。\n1984年在反垄断法的要求下，AT\u0026amp;T按地区划分出去7家小贝尔（Baby Bells）。\n作者指出反垄断法并没有导致AT\u0026amp;T的衰弱，利令智昏和互联网的兴起才是AT\u0026amp;T衰弱的原因。\n1995年达到AT\u0026amp;T公司的顶峰，但是在接下来短短十年之间分崩离析。\n1996年分离成AT\u0026amp;T、朗讯和NCR三家公司。贝尔实验室也被一分为二，朗讯的那一半沿用了贝尔实验室的命长，AT\u0026amp;T实验室后更名为香农实验室（Shannon Labs）。\nAT\u0026amp;T不断地被拆分上市，华尔街的投资者、股权持有者在短线投资上获得了巨大的利益，而公司却走向了深渊。另外加上互联网的兴起，可替代的实时通讯方式增多，而电话业务需求量变少。最后被自己分离的子公司SBC收购，后被法国的阿尔卡特并购，AT\u0026amp;T从此消亡。为了撑高股价，朗讯在互联网泡沫经济年代借钱给各个公司来购买朗讯设备，只要设备被运出就会计入季度的销售额，后来借钱买设备的公司纷纷倒闭，应收款项全部都变成了净亏损。\n一些印象深刻的话：\n花旗银行的以为由20年资本管理经验的副总裁对我讲，评价一个上市公司的还坏，其实只要看哪些最优秀的人是流进这家公司的，还是流出这家公司的即可。（想到之前听朋友说的李航去了字节的消息，一查还是2017年的事）\n另外，1972年，Unix操作系统和c语言诞生于贝尔实验室。距今不过50年\nIBM 蓝色巨人IBM自1924以来屹立百年。\nApple 一切都围绕乔布斯这个传奇任务展开。\n","permalink":"https://Isaray.github.io/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["IT","History"],"title":"浪潮之巅阅读笔记"},{"categories":["Notes"],"contents":"Zotero\nZotero是一款开源文献管理软件，功能和EndNote相似，但是其丰富的插件使其具有十分强大的功能。\n到官网（Zotero | Downloads）下载对应版本的Zotero和浏览器插件。\n按照网上教程安装Zotero插件，参考连接如下：\nZotero的插件介绍 - 知乎 (zhihu.com)\n安装quicklook后点击空格就可以预览。\nZotero网盘同步及文件夹重命名 - 知乎 (zhihu.com)\n所有文件都存储到了onedrive的文件夹下。\n下载坚果云客户端，配置文件夹可以达到同样的效果。\n","permalink":"https://Isaray.github.io/zotero/","tags":["Tools"],"title":"Zotero的使用"},{"categories":["Tutorial"],"contents":"Build our own website by using Hugo on Wins Hugo is said to be the world\u0026rsquo;s fastest framework for building websites.\nThe world’s fastest framework for building websites | Hugo (gohugo.io)\nInstall Hugo There are so many tutorials for installing hugo on macOS and Linux, and this blog mainly fucuses on how to install hugo on Windows.\nAnd I recommend using method two.\nMethod One： Using Official Docs Hugo official installation file：\nInstall Hugo | Hugo (gohugo.io)\nFirst, make sure you have chocolatey on your laptop with Windows system.\n1. Install chocolatey on Windows Chocolatey Software Docs | Setup / Install\n Please remember to start a command prompt as an administrator.\n run the following command:\n1  @\u0026#34;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#34; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \u0026#34;[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET \u0026#34;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\u0026#34;   Check whether hugo is installed successfully with the following command:\n1  choco help   2.Install Hugo with Chocolatey\nIf you are on a Windows machine and use Chocolatey for package management, you can install Hugo with the following one-liner:\ninstall-with-chocolatey.ps1\n1  choco install hugo -confirm   Or if you need the “extended” Sass/SCSS version:\ninstall-extended-with-chocolatey.ps1\n1  choco install hugo-extended -confirm   Method Two：Download hugo.exe directly 1.Download Hugo Releases · gohugoio/hugo (github.com)\n Download the certain version you need. Some website themes have requirements of hugo version.\n 2. Set Environment Variables Set the folder of hugo.exe as environment variables.\nThen, open another command line to check whether it is successfully set or not. Run the command in CMD:\nhugo version\nThemes I Prefered There are many themes on the official websites.\nComplete List | Hugo Themes (gohugo.io)\nPersonally I prefered the following themes.\nAcademic | Hugo Themes (gohugo.io)\nAcademic | Hugo Themes (gohugo.io)\nPaperMod | Hugo Themes (gohugo.io)\nEven | Hugo Themes (gohugo.io)\nTranquilpeak | Hugo Themes (gohugo.io)\nClean White | Hugo Themes (gohugo.io)\nLoveIt | Hugo Themes (gohugo.io)\nI use the theme LoveIt.\nLoveIt (hugoloveit.com)\nInstall it according to the official document and try to build demo yourself.\nTheme Documentation - Basics - LoveIt (hugoloveit.com)\nYou can also follow the steps in this video. Although it is on the MacOS system, she explained everything clearly in Chinese.\nHugo - 10分钟搭建 \u0026amp; 部署个人网站/博客，简历中的博客网站怎么建哔哩哔哩bilibili\n Memos Important Command 1.hugo serve Executehugo serve under the root folder of the project, click http://localhost:1313/ to visit your website locally.\n2.hugo  make sure that in the config.toml , it is written like baseUrl=\u0026ldquo;https://[username].github.io\u0026rdquo; Executehugo under the root folder of the project. For the first time you do it, the public folder will be made. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo.  Publish on GitHub Pages   new a repository，setting it to public。\n  Set the address of your blog [username].github.io at setting/pages. Set the branch to master if you use it.\n  Executehugo under the root folder of the project. For the first time you do it, the public folder will be made.(make sure that in the config.toml , it is written like baseUrl=\u0026ldquo;https://[username].github.io\u0026rdquo;)\ncd public, run the command:\n1 2 3 4 5  git init git add . git commit -m\u0026#34;first commit\u0026#34; git add remote origin \u0026#34;your reposotory address\u0026#34; git push -u origin master     Wait a few minites，and you can visit your website on https://[username].github.io.\ntips:\n If the your website doesn\u0026rsquo;t change after a sucessful push, please check the actions of repository. The compiling of new github pages probably failed.\n  If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo.\n Some mistakes I met If the style/css of the website went wrong, you should check the url and address in index.html page. Perhaps the baseUrl is wrong.\nThe Extended Functions of LoveIt： Hugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 - Yulin Lewis' Blog (lewky.cn)\nThere are four blogs in the link , including the improvements of searching！\nThe official link is also helpful.\nTheme Documentation - Extended Shortcodes - LoveIt (hugoloveit.com)\nSave My config.toml I revise the config.toml according to the offical demo and files,\nincluding:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;xxx\u0026#34; [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.png\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;xxx\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;这是我的全新 Hugo 网站\u0026#34; # 是否保持使用文章前面的静态目录 keepStatic = false [params.list] # list 页面每页显示文章数量 paginate = 10 ...   Here is my config.toml\nI delete the function of comments, because it goes wrong on github pages.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535  baseURL = \u0026#34;https://xxx.github.io/\u0026#34; # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \u0026#34;en\u0026#34; # language code languageCode = \u0026#34;en\u0026#34; title = \u0026#34;xxx\u0026#39;s blog\u0026#34; # Change the default theme to be use when building the site with Hugo theme = [\u0026#34;hugo-search-fuse-js\u0026#34;,\u0026#34;LoveIt\u0026#34;] # whether to use emoji code # 是否使用 emoji 代码 enableEmoji = true [menu] [[menu.main]] identifier = \u0026#34;posts\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons pre = \u0026#34;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons post = \u0026#34;\u0026#34; name = \u0026#34;Posts\u0026#34; url = \u0026#34;/posts/\u0026#34; # title will be shown when you hover on this menu link title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;projects\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons pre = \u0026#34;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons post = \u0026#34;\u0026#34; name = \u0026#34;Projects\u0026#34; url = \u0026#34;/categories/projects/\u0026#34; # title will be shown when you hover on this menu link title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; weight = 5 [[menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;search\u0026#34; weight = 7 identifier = \u0026#34;search\u0026#34; url = \u0026#34;/search/\u0026#34; [params] # LoveIt 主题版本 version = \u0026#34;0.2.X\u0026#34; # 网站描述 description = \u0026#34;这是我的全新 Hugo 网站\u0026#34; # 网站关键词 keywords = [\u0026#34;Theme\u0026#34;, \u0026#34;Hugo\u0026#34;] # 网站默认主题样式 (\u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;, \u0026#34;auto\u0026#34;) defaultTheme = \u0026#34;auto\u0026#34; # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \u0026#34;\u0026#34; # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\u0026#34;sha256\u0026#34;, \u0026#34;sha384\u0026#34;, \u0026#34;sha512\u0026#34;, \u0026#34;md5\u0026#34;) fingerprint = \u0026#34;\u0026#34; # 日期格式 dateFormat = \u0026#34;2006-01-02\u0026#34; # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\u0026#34;/logo.png\u0026#34;] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;LoveIt\u0026#34; # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#34;\u0026#34; # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-10磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; # 搜索配置 [params.search] enable = false # 搜索引擎的类型 (\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;) type = \u0026#34;lunr\u0026#34; # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \u0026#34;\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) desktopMode = \u0026#34;fixed\u0026#34; # 移动端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) mobileMode = \u0026#34;auto\u0026#34; # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;Isaray\u0026#39;s blog\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = \u0026#39;\u0026#39; # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \u0026#34;\u0026#34; # 许可协议信息 (支持 HTML 格式) license = \u0026#39;\u0026lt;a rel=\u0026#34;license external nofollow noopener noreffer\u0026#34; href=\u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;CC BY-NC 4.0\u0026lt;/a\u0026gt;\u0026#39; # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 10 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 10 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.png\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;xxx\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;A student major in Data Science and Engineering.\u0026#34; # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \u0026#34;hiddenFromHomePage\u0026#34; 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \u0026#34;https://github.com/Isaray\u0026#34; Linkedin = \u0026#34;xxxx\u0026#34; Twitter = \u0026#34;\u0026#34; Instagram = \u0026#34;xxxx\u0026#34; Facebook = \u0026#34;\u0026#34; Telegram = \u0026#34;xxxx\u0026#34; Medium = \u0026#34;\u0026#34; Gitlab = \u0026#34;\u0026#34; Youtubelegacy = \u0026#34;\u0026#34; Youtubecustom = \u0026#34;\u0026#34; Youtubechannel = \u0026#34;\u0026#34; Tumblr = \u0026#34;\u0026#34; Quora = \u0026#34;\u0026#34; Keybase = \u0026#34;\u0026#34; Pinterest = \u0026#34;\u0026#34; Reddit = \u0026#34;\u0026#34; Codepen = \u0026#34;\u0026#34; FreeCodeCamp = \u0026#34;\u0026#34; Bitbucket = \u0026#34;\u0026#34; Stackoverflow = \u0026#34;\u0026#34; Weibo = \u0026#34;\u0026#34; Odnoklassniki = \u0026#34;\u0026#34; VK = \u0026#34;\u0026#34; Flickr = \u0026#34;\u0026#34; Xing = \u0026#34;\u0026#34; Snapchat = \u0026#34;\u0026#34; Soundcloud = \u0026#34;\u0026#34; Spotify = \u0026#34;\u0026#34; Bandcamp = \u0026#34;\u0026#34; Paypal = \u0026#34;\u0026#34; Fivehundredpx = \u0026#34;\u0026#34; Mix = \u0026#34;\u0026#34; Goodreads = \u0026#34;\u0026#34; Lastfm = \u0026#34;\u0026#34; Foursquare = \u0026#34;\u0026#34; Hackernews = \u0026#34;\u0026#34; Kickstarter = \u0026#34;\u0026#34; Patreon = \u0026#34;\u0026#34; Steam = \u0026#34;\u0026#34; Twitch = \u0026#34;\u0026#34; Strava = \u0026#34;\u0026#34; Skype = \u0026#34;\u0026#34; Whatsapp = \u0026#34;\u0026#34; Zhihu = \u0026#34;\u0026#34; Douban = \u0026#34;\u0026#34; Angellist = \u0026#34;\u0026#34; Slidershare = \u0026#34;\u0026#34; Jsfiddle = \u0026#34;\u0026#34; Deviantart = \u0026#34;\u0026#34; Behance = \u0026#34;\u0026#34; Dribbble = \u0026#34;\u0026#34; Wordpress = \u0026#34;\u0026#34; Vine = \u0026#34;\u0026#34; Googlescholar = \u0026#34;\u0026#34; Researchgate = \u0026#34;\u0026#34; Mastodon = \u0026#34;\u0026#34; Thingiverse = \u0026#34;\u0026#34; Devto = \u0026#34;\u0026#34; Gitea = \u0026#34;\u0026#34; XMPP = \u0026#34;\u0026#34; Matrix = \u0026#34;\u0026#34; Bilibili = \u0026#34;\u0026#34; Email = \u0026#34;xxxx@xxxx.com\u0026#34; RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前面的静态目录 #修改为动态 keepStatic = false # 是否使侧边目录自动折叠展开 auto = true # 代码配置 [params.page.code] # 是否显示代码块的复制按钮 copy = true # 默认展开显示的代码行数 maxShownLines = 10 # KaTeX 数学公式 [params.page.math] enable = true # 默认块定界符是 $$ ... $$ 和 \\\\[ ... \\\\] blockLeftDelimiter = \u0026#34;\u0026#34; blockRightDelimiter = \u0026#34;\u0026#34; # 默认行内定界符是 $ ... $ 和 \\\\( ... \\\\) inlineLeftDelimiter = \u0026#34;\u0026#34; inlineRightDelimiter = \u0026#34;\u0026#34; # KaTeX 插件 copy_tex copyTex = true # KaTeX 插件 mhchem mhchem = true # Mapbox GL JS 配置 [params.page.mapbox] # Mapbox GL JS 的 access token accessToken = \u0026#34;\u0026#34; # 浅色主题的地图样式 lightStyle = \u0026#34;mapbox://styles/mapbox/light-v9\u0026#34; # 深色主题的地图样式 darkStyle = \u0026#34;mapbox://styles/mapbox/dark-v9\u0026#34; # 是否添加 NavigationControl navigation = true # 是否添加 GeolocateControl geolocate = true # 是否添加 ScaleControl scale = true # 是否添加 FullscreenControl fullscreen = true # 文章页面的分享信息设置 [params.page.share] enable = true Twitter = true Facebook = true Linkedin = false Whatsapp = true Pinterest = false Tumblr = false HackerNews = false Reddit = false VK = false Buffer = false Xing = false Line = true Instapaper = false Pocket = false Digg = false Stumbleupon = false Flipboard = false Weibo = true Renren = false Myspace = true Blogger = true Baidu = false Odnoklassniki = false Evernote = true Skype = false Trello = false Mix = false # 第三方库配置 [params.page.library] [params.page.library.css] # someCSS = \u0026#34;some.css\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someCSS = \u0026#34;https://cdn.example.com/some.css\u0026#34; [params.page.library.js] # someJavascript = \u0026#34;some.js\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someJavascript = \u0026#34;https://cdn.example.com/some.js\u0026#34; # 页面 SEO 配置 [params.page.seo] # 图片 URL images = [] # 出版者信息 [params.page.seo.publisher] name = \u0026#34;\u0026#34; logoUrl = \u0026#34;\u0026#34; # TypeIt 配置 [params.typeit] # 每一步的打字速度 (单位是毫秒) speed = 100 # 光标的闪烁速度 (单位是毫秒) cursorSpeed = 1000 # 光标的字符 (支持 HTML 格式) cursorChar = \u0026#34;|\u0026#34; # 打字结束之后光标的持续时间 (单位是毫秒, \u0026#34;-1\u0026#34; 代表无限大) duration = -1 # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [params.verification] google = \u0026#34;\u0026#34; bing = \u0026#34;\u0026#34; yandex = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; baidu = \u0026#34;\u0026#34; # 网站 SEO 配置 [params.seo] # 图片 URL image = \u0026#34;\u0026#34; # 缩略图 URL thumbnailUrl = \u0026#34;\u0026#34; # 网站分析配置 [params.analytics] enable = false # Google Analytics [params.analytics.google] id = \u0026#34;\u0026#34; # 是否匿名化用户 IP anonymizeIP = true # Fathom Analytics [params.analytics.fathom] id = \u0026#34;\u0026#34; # 自行托管追踪器时的主机路径 server = \u0026#34;\u0026#34; # Cookie 许可配置 [params.cookieconsent] enable = true # 用于 Cookie 许可横幅的文本字符串 [params.cookieconsent.content] message = \u0026#34;\u0026#34; dismiss = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # 第三方库文件的 CDN 设置 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\u0026#34;jsdelivr.yml\u0026#34;) # 位于 \u0026#34;themes/LoveIt/assets/data/cdn/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/data/cdn/\u0026#34; data = \u0026#34;\u0026#34; # 兼容性设置 [params.compatibility] # 是否使用 Polyfill.io 来兼容旧式浏览器 polyfill = false # 是否使用 object-fit-images 来兼容旧式浏览器 objectFit = false # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 # 作者配置 [author] name = \u0026#34;Isaray\u0026#34; email = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # 网站地图配置 [sitemap] changefreq = \u0026#34;weekly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 # Permalinks 配置 [Permalinks] # posts = \u0026#34;:year/:month/:filename\u0026#34; posts = \u0026#34;:filename\u0026#34; # 隐私信息配置 [privacy] # Google Analytics 相关隐私 (被 params.analytics.google 替代) [privacy.googleAnalytics] # ... [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\u0026#34;text/plain\u0026#34;] suffixes = [\u0026#34;md\u0026#34;] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \u0026#34;text/plain\u0026#34; isPlainText = true isHTML = false # 用于 Hugo 输出文档的设置 [outputs] # home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] page = [\u0026#34;HTML\u0026#34;, \u0026#34;MarkDown\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;]   ","permalink":"https://Isaray.github.io/build_websites_with_hugo/","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?"},{"categories":["Notes"],"contents":"1.递归 1.1算法策略 把问题分解成更小规模的同类子问题，用递归调用的方法求解问题。\n1.2 适用场景 引用知乎一篇文章的总结\n递归算法一般用于解决三类问题：\n 数据的定义是按递归定义的。（斐波那契数列） 问题解法按递归算法实现。（回溯） 数据的结构形式是按递归定义的。（树的遍历，图的搜索）  解题策略 （1）明确输入输出\n（2）明确递归结束条件\n（3）明确递归关系式\n1.3经典问题  斐波那契数列 汉诺塔问题 树的遍历及相关操作  2.分治 2.1算法策略 将一个问题分解成多个子问题，每个子问题又可以分解成更小的子问题，直到子问题可以被求解。原问题是子问题的合并。\n2.2适用场景 当出现满足以下条件的问题，可以尝试只用分治策略进行求解：\n 原始问题可以分成多个相似的子问题 子问题可以很简单的求解 原始问题的解是子问题解的合并 各个子问题是相互独立的，不包含相同的子问题  解题策略  分解大问题 解决子问题 合并子问题结果  2.3经典问题  二分查找 归并排序 快速排序 汉诺塔问题 React 时间分片  3.贪心 3.1算法策略 总是选择当下最优的解决方案。\n3.2适用场景 当满足一下条件时，可以使用：\n 原问题复杂度过高 求全局最优解的数学模型难以建立或计算量过大 没有太大必要一定要求出全局最优解，“比较优”就可以  解题策略  定义最优解条件 把问题分解成多个步骤，每一步要满足  可行性：每一步都满足问题的约束 局部最优 不可取消    最后叠加所有步骤得到最优解。\n3.3经典问题 使用贪心算法求解的经典问题有：\n 最小生成树算法 单源最短路径的 Dijkstra 算法 Huffman 压缩编码 背包问题 活动选择问题等  4.回溯 4.1算法策略 步步尝试，不行回退。\n4.2适用场景 不断的尝试，直到拿到解。从一组可能的解中，选择一个满足要求的解。\n4.3经典问题  深度优先搜索 0-1背包问题 正则表达式匹配 八皇后 数独 全排列  5.动态规划 5.1算法策略 Taking notes.\n将复杂问题分解成小问题求解，各个子问题之间有重合，结果可以复用。\n5.2适用场景 求解最优解。\n解题策略 需要遵循以下几个重要步骤：\n 定义子问题 实现需要反复执行解决的子子问题部分 识别并求解出边界条件  5.3经典问题  爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）  6.枚举 6.1算法策略 一一列举，明确列举范围。\n6.3经典问题 参考：\n95% 的算法都是基于这 6 种算法思想！！！ - 知乎 (zhihu.com)\nBAT机器学习面试1000题系列_HuangQinJian-CSDN博客_bat机器学习1000题\n剑指offer-Python版（上） - 知乎 (zhihu.com)\n1.bfs,dfs dfs可以看作不知道层数情况下的枚举法，用到递归的思想。\n回溯算法，先列举出来再还原。\n全排列\n1 2 3 4 5 6 7 8 9 10 11  class Solution2: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: res = [] def backtrack(nums, tmp): if not nums: res.append(tmp) return for i in range(len(nums)): backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]]) backtrack(nums, []) return res   岛屿数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def numIslands(self, grid): row, col, ret = len(grid), len(grid[0]), 0 def dfs(x, y): grid[x][y] = \u0026#39;0\u0026#39; for c in [[0, 1], [0, -1], [1, 0], [-1, 0]]: nx, ny = x + c[0], y + c[1] if 0 \u0026lt;= nx \u0026lt; row and 0 \u0026lt;= ny \u0026lt; col and grid[nx][ny] == \u0026#39;1\u0026#39;: dfs(nx, ny) for i in range(row): for j in range(col): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(i, j) ret += 1 return ret   2.binary search 求x的平方根\n1 2 3 4 5 6 7 8 9 10 11  class Solution: def mySqrt(self, x: int) -\u0026gt; int: l, r, ans = 0, x, -1 while l \u0026lt;= r: mid = (l + r) // 2 if mid * mid \u0026lt;= x: ans = mid l = mid + 1 else: r = mid - 1 return ans   3.sliding window move them simutanously 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。\n示例 1:\n输入: s = \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\n1 2 3 4 5 6 7 8 9  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: cur, res = [], 0 for r in range(len(s)): while s[r] in cur: cur.pop(0) # 左边出 cur.append(s[r]) # 右侧无论如何都会进入新的 res = max(len(cur),res) return res   recursion\nfibonacci, binary tree\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def hanota(self, A: List[int], B: List[int], C: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify C in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(A) self.move(n, A, B, C) def move(self, n, A, B, C): if n == 1: C.append(A.pop()) else: self.move(n-1, A, C, B) C.append(A.pop()) self.move(n-1, B, A, C)   inverting into binary tree\nreverse a linked list\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution(object): def reverseList(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; # 申请两个节点，pre和 cur，pre指向None pre = None cur = head # 遍历链表，while循环里面的内容其实可以写成一行 # 这里只做演示，就不搞那么骚气的写法了 while cur: # 记录当前节点的下一个节点 tmp = cur.next # 然后将当前节点指向pre cur.next = pre # pre和cur节点都前进一位 pre = cur cur = tmp return pre   suffix trees\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Trie: def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix: str) -\u0026gt; \u0026#34;Trie\u0026#34;: node = self for ch in prefix: ch = ord(ch) - ord(\u0026#34;a\u0026#34;) if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word: str) -\u0026gt; None: node = self for ch in word: ch = ord(ch) - ord(\u0026#34;a\u0026#34;) if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word: str) -\u0026gt; bool: node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix: str) -\u0026gt; bool: return self.searchPrefix(prefix) is not None   heaps\nrepeatedly find min,max\n第 k 个最大的元素\n1 2 3 4 5 6 7 8 9 10 11  class Solution: def findKthLargest(self, nums: List[int], k: int) -\u0026gt; int: # 构造大小为 k 的小顶堆 heap = [x for x in nums[:k]] heapq.heapify(heap) n = len(nums) for i in range(k, n): if nums[i] \u0026gt; heap[0]: heapq.heappop(heap) heapq.heappush(heap, nums[i]) return heap[0]   dynamic programming\nsorting algorithm\nquick sort and merge sort\n","permalink":"https://Isaray.github.io/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/","tags":["Python","Algorithm"],"title":"六种常见算法"},{"categories":["Experiments"],"contents":"CSAPP:memory mountain 画memory mountain存储器山： https://blog.csdn.net/weixin_41724000/article/details/100072251 http://csapp.cs.cmu.edu/3e/students.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  /* mountain.c - Generate the memory mountain. */ /* $begin mountainmain */ #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026#34;fcyc2.h\u0026#34; /* measurement routines */#include \u0026#34;clock.h\u0026#34; /* routines to access the cycle counter */ #define MINBYTES (1 \u0026lt;\u0026lt; 14) /* First working set size */#define MAXBYTES (1 \u0026lt;\u0026lt; 27) /* Last working set size */#define MAXSTRIDE 15 /* Stride x8 bytes */#define MAXELEMS MAXBYTES/sizeof(long)  /* $begin mountainfuns */ long data[MAXELEMS]; /* The global array we\u0026#39;ll be traversing */ /* $end mountainfuns */ /* $end mountainmain */ void init_data(long *data, int n); int test(int elems, int stride); double run(int size, int stride, double Mhz); /* $begin mountainmain */ int main() { int size; /* Working set size (in bytes) */ int stride; /* Stride (in array elements) */ double Mhz; /* Clock frequency */ init_data(data, MAXELEMS); /* Initialize each element in data */ Mhz = mhz(0); /* Estimate the clock frequency */ /* $end mountainmain */ /* Not shown in the text */ printf(\u0026#34;Clock frequency is approx. %.1f MHz\\n\u0026#34;, Mhz); printf(\u0026#34;Memory mountain (MB/sec)\\n\u0026#34;); printf(\u0026#34;\\t\u0026#34;); for (stride = 1; stride \u0026lt;= MAXSTRIDE; stride++) printf(\u0026#34;s%d\\t\u0026#34;, stride); printf(\u0026#34;\\n\u0026#34;); /* $begin mountainmain */ for (size = MAXBYTES; size \u0026gt;= MINBYTES; size \u0026gt;\u0026gt;= 1) { /* $end mountainmain */ /* Not shown in the text */ if (size \u0026gt; (1 \u0026lt;\u0026lt; 20)) printf(\u0026#34;%dm\\t\u0026#34;, size / (1 \u0026lt;\u0026lt; 20)); else printf(\u0026#34;%dk\\t\u0026#34;, size / 1024); /* $begin mountainmain */ for (stride = 1; stride \u0026lt;= MAXSTRIDE; stride++) { printf(\u0026#34;%.0f\\t\u0026#34;, run(size, stride, Mhz)); } printf(\u0026#34;\\n\u0026#34;); } exit(0); } /* $end mountainmain */ /* init_data - initializes the array */ void init_data(long *data, int n) { int i; for (i = 0; i \u0026lt; n; i++) data[i] = i; } /* $begin mountainfuns */ /* test - Iterate over first \u0026#34;elems\u0026#34; elements of array \u0026#34;data\u0026#34; with * stride of \u0026#34;stride\u0026#34;, using 4x4 loop unrolling. */ int test(int elems, int stride) { long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4; long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0; long length = elems; long limit = length - sx4; /* Combine 4 elements at a time */ for (i = 0; i \u0026lt; limit; i += sx4) { acc0 = acc0 + data[i]; acc1 = acc1 + data[i+stride]; acc2 = acc2 + data[i+sx2]; acc3 = acc3 + data[i+sx3]; } /* Finish any remaining elements */ for (; i \u0026lt; length; i++) { acc0 = acc0 + data[i]; } return ((acc0 + acc1) + (acc2 + acc3)); } /* run - Run test(elems, stride) and return read throughput (MB/s). * \u0026#34;size\u0026#34; is in bytes, \u0026#34;stride\u0026#34; is in array elements, and Mhz is * CPU clock frequency in Mhz. */ double run(int size, int stride, double Mhz) { double cycles; int elems = size / sizeof(double); test(elems, stride); /* Warm up the cache */ //line:mem:warmup  cycles = fcyc2(test, elems, stride, 0); /* Call test(elems,stride) */ //line:mem:fcyc  return (size / stride) / (cycles / Mhz); /* Convert cycles to MB/s */ //line:mem:bwcompute } /* $end mountainfuns */   ","permalink":"https://Isaray.github.io/csapp-memory_mountain/","tags":["CSAPP","Courses"],"title":"CSAPP:memory mountain"},{"categories":["Experiments"],"contents":"CSAPP:shlab 该实验对应CSAPP第8章：异常控制流，可以先温习该章内容再做实验。\n通读实验指南，了解实验目的：\n简介 The purpose of this assignment is to become more familiar with the concepts of process control and signalling. You’ll do this by writing a simple Unix shell program that supports job control.\n本实验的目的就是写一个简单的Unix shell，主要任务就是修改tsh.c文件，需修改以下7个函数。\n   1.void eval(char *cmdline); //解释命令[70 lines]\n  2.int builtin_cmd(char **argv);//识别命令是否为内置命令quit、jobs、fg、bg ，若是，则执行对应命令.[25 lines]\n    quit命令会终止shell。 jobs 命令列出所有后台工作。 bg 命令通过发送一个 SIGCONT 信号重新启动，然后在后台运行。参数可以是 PID 或 JID。 fg 命令通过发送一个 SIGCONT 信号重新启动，然后在前台运行。     3.void do_bgfg(char **argv);//执行bg,fg操作[50 lines]\n  4.void waitfg(pid_t pid);//等待前台操作完成 [20 lines]\n  5.void sigchld_handler(int sig);//抓住 SIGCHILD [信号80 lines]\n  6.void sigtstp_handler(int sig);//抓住 SIGINT (ctrl-c) 信号[15 lines]\n  7.void sigint_handler(int sig);//抓住 SIGTSTP (ctrl-z) 信号[15 lines]\n   关于你输入的命令： 如果第一个词是内置的命令，shell会在当前进程中立即执行该命令，否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。\n如果命令行以\u0026quot;\u0026amp;\u0026ldquo;结尾，则作业在后台运行，这意味着shell在打印提示符和等待下一行命令前，不会等待job结束。否则，job在前台运行，这意味着shell在等待下一个命令行之前会等待job终止。因此，在任何时间点上，最多只能有一个job在前台运行。但是，可以有任意数量的job在后台运行。\n下面一段说明很好地解释了main中的参数argc、argv代表什么意思（这里环境的参数被省略了）：\n Typing the command line tsh\u0026gt; /bin/ls -l -d runs the ls program in the foreground. By convention, the shell ensures that when the program begins executing its main routine\nint main(int argc, char *argv[])\nthe argc and argv arguments have the following values:\n• argc == 3,\n• argv[0] == ‘‘/bin/ls’’,\n• argv[1]== ‘‘-l’’,\n• argv[2]== ‘‘-d’’.\nargc指的是参数个数，argv是指针数组，每个指针指向一个参数字符串。\n 一些注意事项：\n 如果命令行以＆结束，则tsh应该在后台运行job。 否则，它将在前台运行该job。 每个作业都可以由进程ID（PID）或作业ID（JID）标识，该ID是tsh分配的正整数。 JID应该在命令行上以前缀“％”表示。 例如，“％5”表示JID 5，“ 5”表示PID5。 tsh应该管理回收（reap）所有的僵尸子进程。 如果任何job由于接收到未捕获到的信号而终止，则tsh应该识别此事件并打印一条带有该job的PID的消息以及对该问题的信号的描述。 job Id 和 process id 是有区别的，前者需要以%为前缀，后者为一个数字。这一点在处理bg、fg指令时尤为重要 在eval中一定要   在fork子进程前用sigprocmask阻塞SIGCHLD信号；fork之后解除该阻塞 在加子进程到joblist前调用sigprocmask阻塞全部信号 因为子进程会从父进程处继承阻塞信息，所以在execve其他二进制文件前，一定要解除信号阻塞 子进程按照建议应该在 sigchld_handler被收割（reap），所以父进程需要在调用addjob之前阻塞SIGCHLD信号，以防止竞态条件   当在标准unix shell中运行tsh程序时，从tsh程序fork出来的子程序会和tsh处于同一个process group；因此你需要使用setpgid来重置子进程process group id；如若不然，在ctrl-c \u0026amp; ctrl-z的处理上会有一些问题 用sigprocmask阻塞信号，因为有时候不希望在接到信号时就立即停止当前执行，去处理信号，同时也不希望忽略该信号，而是延时一段时间去调用信号处理函数。  检验结果用到的一些命令 先make\n共16组测试数据，test结果要和rtest完全一样才算通过。\nmake test01 相当于 ./sdriver.pl -t trace01.txt -s ./tsh -a \u0026quot;-p\u0026quot;\nmake rtest01 相当于 ./sdriver.pl -t trace01.txt -s ./tshref -a \u0026quot;-p\u0026quot;\n实验代码和注释 eval eval解析输入的命令： 如果第一个词是内置的命令builtin_cmd(argv)，shell会在当前进程中立即执行该命令。 否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。\n 注意：在创建子进程前要阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，导致信号丢失，所以在fork子进程前阻塞sigchld信号，并在fork,addjob后解除\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  /* * eval - Evaluate the command line that the user has just typed in * * If the user has requested a built-in command (quit, jobs, bg or fg) * then execute it immediately. Otherwise, fork a child process and * run the job in the context of the child. If the job is running in * the foreground, wait for it to terminate and then return. Note: * each child process must have a unique process group ID so that our * background children don\u0026#39;t receive SIGINT (SIGTSTP) from the kernel * when we type ctrl-c (ctrl-z) at the keyboard. */ void eval(char *cmdline) {\t// static char array[MAXLINE]; /* holds local copy of command line */ // char *buf = array; /* ptr that traverses command line */ char *argv[MAXARGS];\t//命令行参数 pid_t pid;\t//子进程PID int bg; // 最后是否是\u0026amp;，即是否后台执行， sigset_t mask_one, prev, mask_all; // strcpy(buf, cmdline);\t//缓存命令行 bg = parseline(cmdline, argv); if(argv[0] == NULL) return;//忽略空行 if(!builtin_cmd(argv)){//如果不是shell的内嵌命令 sigemptyset(\u0026amp;mask_one);//初始化信号量集 sigaddset(\u0026amp;mask_one, SIGCHLD);//将SIGCHLD添加到信号量集中 sigfillset(\u0026amp;mask_all);// 设置全阻塞 sigprocmask(SIG_BLOCK, \u0026amp;mask_one, \u0026amp;prev);//阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，所以在fork子进程前阻塞sigchld信号，addjob后解除 if((pid = fork()) == 0){\t// 子进程继承了父进程的阻塞向量，也要解除阻塞，避免收不到它本身的子进程的信号 setpgid(0, 0);\t//把pid=0放到gpid=0的进程组 sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL);//恢复被屏蔽的信号，防止遗漏 //容错 if(execve(argv[0], argv, environ) \u0026lt; 0){ printf(\u0026#34;%s: Command not found\\n\u0026#34;, argv[0]); exit(0); } } sigprocmask(SIG_BLOCK, \u0026amp;mask_all, NULL); addjob(jobs, pid, bg?BG:FG, cmdline); sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL);\tif(bg){ //在后台解除屏蔽\tprintf(\u0026#34;[%d] (%d) %s\u0026#34;, pid2jid(pid), pid, cmdline); }else{\twaitfg(pid); } } return; }   builtin_cmd 判断是否内置命令（1是，0否），并执行对应操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /* * builtin_cmd - If the user has typed a built-in command then execute * it immediately. */ int builtin_cmd(char **argv) { if(!strcmp(argv[0], \u0026#34;quit\u0026#34;)){ exit(0); } if(!strcmp(argv[0], \u0026#34;jobs\u0026#34;)){ listjobs(jobs); return 1; } if(!strcmp(argv[0], \u0026#34;\u0026amp;\u0026#34;)){ // ignore singleton \u0026#39;\u0026amp;\u0026#39; return 1; } if(!strcmp(argv[0], \u0026#34;bg\u0026#34;) || !strcmp(argv[0], \u0026#34;fg\u0026#34;)){ do_bgfg(argv); return 1; } return 0; /* not a builtin command */ }   do_bgfg 在命令行中的第一个参数argv[0]可以用于判断输入的是bg还是fg命令。 PID和JID有不同的格式，分别用不同的方式读入sscanf(argv[1],\u0026quot;%d\u0026rdquo;,\u0026amp;pid)和sscanf(argv[1],\u0026quot;%%%d\u0026quot;,\u0026amp;jid)，若都不是，则会输出错误提示。\n  每个作业都可以由进程ID（PID）或作业ID（JID）标识，该ID是tsh分配的正整数。 JID应该在命令行上以前缀“％”表示。 例如，“％5”表示JID 5，“ 5”表示PID5。   看process或者job是否存在，不存在则报错，若存在则修改状态，并重启。 若是fg前台则等待前一个进程结束，若是bg后台则输出相应字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  /* * do_bgfg - Execute the builtin bg and fg commands */ void do_bgfg(char **argv) {\tint jid; struct job_t *job; pid_t pid; sigset_t mask, prev; //argv[0]判断bg还是fg if(argv[1] == NULL){ printf(\u0026#34;%s command requires PID or %%jobid argument\\n\u0026#34;,argv[0]); return; } //首先确定是pid还是jid，然后将其转化为kill的参数 //读jid if(sscanf(argv[1],\u0026#34;%%%d\u0026#34;,\u0026amp;jid) \u0026gt; 0){\tjob = getjobjid(jobs, jid);\t//需要获得job，因为要修改job信息 if(job == NULL || job-\u0026gt;state == UNDEF){ printf(\u0026#34;%s: No such job\\n\u0026#34;, argv[1]); return; } //读pid }else if(sscanf(argv[1],\u0026#34;%d\u0026#34;,\u0026amp;pid) \u0026gt; 0){\tjob = getjobpid(jobs, pid); if(job == NULL || job-\u0026gt;state == UNDEF){ printf(\u0026#34;(%s): No such process\\n\u0026#34;, argv[1]); return; } }else{ printf(\u0026#34;%s: argument must be a PID or %%jobid\\n\u0026#34;, argv[0]); return; } //修改job信息 sigfillset(\u0026amp;mask); sigprocmask(SIG_BLOCK, \u0026amp;mask, \u0026amp;prev); //更改状态 if(!strcmp(argv[0], \u0026#34;fg\u0026#34;)){\tjob-\u0026gt;state = FG; }else{ job-\u0026gt;state = BG; } sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL); pid = job-\u0026gt;pid; //发送SIGCONT重启 kill(-pid, SIGCONT); if(!strcmp(argv[0], \u0026#34;fg\u0026#34;)){ waitfg(pid);//若是前台则等待前一个进程结束 }else{ printf(\u0026#34;[%d] (%d) %s\u0026#34;, job-\u0026gt;jid, pid, job-\u0026gt;cmdline);//若是后台则输出相应字符串 } return; }   waitfg 等待pid进程不再是前台进程\n1 2 3 4 5 6 7 8 9 10  /* * waitfg - Block until process pid is no longer the foreground process */ void waitfg(pid_t pid) { while(pid == fgpid(jobs)){ sleep(1); } return; }   sigchld_handler //抓住 SIGCHILD 信号 内核在每当子进程终止（成为僵尸）或停止时，因为它收到SIGSTOP或SIGTSTP信号，该处理zombie进程，但不等待任何其他的。终止当前正在运行的子进程。 回收的子进程有三种状态：正常退出、信号退出和信号停止。\n1 2 3 4 5 6 7 8 9 10  if(WIFEXITED(state)){\t// 正常退出 deletejob(jobs, pid); }else if(WIFSIGNALED(state)){\t// 信号退出 printf(\u0026#34;Job [%d] (%d) terminated by signal %d\\n\u0026#34;, pid2jid(pid), pid, WTERMSIG(state));\tdeletejob(jobs, pid); }else if(WIFSTOPPED(state)){\t// 信号停止 job = getjobpid(jobs, pid); job-\u0026gt;state = ST;//注意 printf(\u0026#34;Job [%d] (%d) stopped by signal %d\\n\u0026#34;, job-\u0026gt;jid, pid, WSTOPSIG(state)); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  /***************** * Signal handlers *****************/ /* * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever * a child job terminates (becomes a zombie), or stops because it * received a SIGSTOP or SIGTSTP signal. The handler reaps all * available zombie children, but doesn\u0026#39;t wait for any other * currently running children to terminate. */ void sigchld_handler(int sig) { int old_errno = errno;\tpid_t pid; sigset_t mask, prev; int state;\tstruct job_t *job; sigfillset(\u0026amp;mask);// 设置全阻塞 while((pid = waitpid(-1, \u0026amp;state, WNOHANG | WUNTRACED)) \u0026gt; 0){\t// WNOHANG | WUNTRACED 是立即返回 // 用WIFEXITED(status)，WIFSIGNALED(status)，WIFSTOPPED(status)等来补获终止或者被停止的子进程的退出状态。\tsigprocmask(SIG_BLOCK, \u0026amp;mask, \u0026amp;prev); if(WIFEXITED(state)){\t// 正常退出 deletejob(jobs, pid); }else if(WIFSIGNALED(state)){\t// 信号退出 printf(\u0026#34;Job [%d] (%d) terminated by signal %d\\n\u0026#34;, pid2jid(pid), pid, WTERMSIG(state));\tdeletejob(jobs, pid); }else if(WIFSTOPPED(state)){\t// 停止 job = getjobpid(jobs, pid); job-\u0026gt;state = ST;//注意 printf(\u0026#34;Job [%d] (%d) stopped by signal %d\\n\u0026#34;, job-\u0026gt;jid, pid, WSTOPSIG(state)); } sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL); } errno = old_errno; return; }   sigint_handler 捕捉 SIGINT (ctrl-c) 信号\nsigtstp_handler 捕捉 SIGTSTP (ctrl-z) 信号\n 两个函数写法看起来相似，但是在用sigchld_handler处理的时候有区别，对于 sigtstp_handler我们需要修改job的状态job-\u0026gt;state = ST。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* * sigint_handler - The kernel sends a SIGINT to the shell whenver the * user types ctrl-c at the keyboard. Catch it and send it along * to the foreground job. */ void sigint_handler(int sig) {\tint olderrno=errno; pid_t pid = fgpid(jobs); if(pid!=0){ kill(-pid,sig); } errno = olderrno; return; } /* * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever * the user types ctrl-z at the keyboard. Catch it and suspend the * foreground job by sending it a SIGTSTP. */ void sigtstp_handler(int sig) { int olderrno = errno; pid_t pid = fgpid(jobs); if(pid!=0){ kill(-pid,sig); } errno = olderrno; return; } /********************* * End signal handlers *********************/   参考 README：http://csapp.cs.cmu.edu/3e/README-shlab\n说明：http://csapp.cs.cmu.edu/3e/shlab.pdf\n代码：http://csapp.cs.cmu.edu/3e/shlab-handout.tar\n复习：http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec09.pdf\n博客：\nhttps://zhuanlan.zhihu.com/p/151050267\nhttps://zhuanlan.zhihu.com/p/119034923\nhttps://zhuanlan.zhihu.com/p/89224358\n","permalink":"https://Isaray.github.io/csapp-shlab/","tags":["CSAPP","Courses"],"title":"CSAPP:shlab"},{"categories":["Experiments"],"contents":"CSAPP:malloclab CSAPP:9.9.12 针对空闲块的组织方法有以下三种：\n a.隐式空闲链表(implicit free list) b.显式空闲链表(explicit free list) c.分离空闲链表(segregated free list)  查找空闲块的三个方法：\n a.首次适应(first fit) b.最佳适配(best fit) c.下一次适配(next fit) d.分离适配，特殊情况包括伙伴系统，优点在于快速搜索和快速合并（大小相同，地址连续）。  方案一：隐式空闲链表+first fit/next fit\n 初始化堆 —— mm_init函数 mm_init步骤如下：  首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。\n调extend_heap扩展堆，创建初始的空闲块，大小为4096字节。\n扩展堆 —— extend_heap函数 函数原型: static void *extend_heap(size_t words);  以下两种场景需要扩展堆：\n 调用mm_init初始化堆时。 调用mm_malloc找不到合适的空闲块时。\n 释放和合并块 —— mm_free和coalesce函数   调用mm_free释放块，步骤如下： 将当前块的头部和脚部中的分配位清零。 将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。\n 调用coalesce合并前后的合并块，原型：static void *coalesce(void *bp);，分四种情况：\n 情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。 情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp 情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp) 情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp)\n https://blog.csdn.net/pcj_888/article/details/108812886\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string.h\u0026gt; #include \u0026#34;mm.h\u0026#34;#include \u0026#34;memlib.h\u0026#34; /********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * provide your team information in the following struct. ********************************************************/ team_t team = { /* Team name */ \u0026#34;ateam\u0026#34;, /* First member\u0026#39;s full name */ \u0026#34;Harry Bovik\u0026#34;, /* First member\u0026#39;s email address */ \u0026#34;bovik@cs.cmu.edu\u0026#34;, /* Second member\u0026#39;s full name (leave blank if none) */ \u0026#34;\u0026#34;, /* Second member\u0026#39;s email address (leave blank if none) */ \u0026#34;\u0026#34; }; static char *heap_listp; #define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1\u0026lt;\u0026lt;12) /* Extend heap by this amount (bytes) */ #define MAX(x, y) ((x) \u0026gt; (y) ? (x) : (y))  /* Pack a size and allocated bit into word */ #define PACK(size, alloc) ((size) | (alloc))  /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) #define PUT(p, val) (*(unsigned int *)(p) = (val))  /* Read the size and allocated fields from address p */ #define GET_SIZE(p) (GET(p) \u0026amp; ~0x7) #define GET_ALLOC(p) (GET(p) \u0026amp; 0x1)// 判断这个块是否已分配  /* Given block ptr bp, compute address of its header and footer */ #define HDRP(bp) ((char *)(bp) - WSIZE) #define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)  /* Given block ptr bp, compute address of next and previous blocks */ #define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) #define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))  /* Globe var */ static char *heap_listp; /* 函数声明 */ static void *extend_heap(size_t words); static void *coalesce(void *bp); static void *find_fit(size_t asize); /* single word (4) or double word (8) alignment */ #define ALIGNMENT 8  /* rounds up to the nearest multiple of ALIGNMENT */ #define ALIGN(size) (((size) + (ALIGNMENT-1)) \u0026amp; ~0x7)  #define SIZE_T_SIZE (ALIGN(sizeof(size_t)))  /* * mm_init - initialize the malloc package. */ int mm_init(void) { if((heap_listp=mem_sbrk(4*WSIZE))==(void*)-1) return -1; PUT(heap_listp,0); PUT(heap_listp+(1*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(2*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(3*WSIZE),PACK(0,1)); heap_listp+=(2*WSIZE); if(extend_heap(CHUNKSIZE/WSIZE)==NULL) return -1; return 0; } static void *extend_heap(size_t words){ char *bp; size_t size; size=(words%2)? ((words+1) *WSIZE):(words*WSIZE); if((long)(bp=mem_sbrk(size))==-1) return NULL; PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(NEXT_BLKP(bp)),PACK(0,1)); return coalesce(bp); } void place(void *bp,size_t asize){ size_t csize=GET_SIZE(HDRP(bp)); //若剩下的空间比2*DSIZE占的空间大，那么就分割它  if((csize-asize)\u0026gt;=(2*DSIZE)){ PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); bp=NEXT_BLKP(bp); PUT(HDRP(bp),PACK(csize-asize,0)); PUT(FTRP(bp),PACK(csize-asize,0)); } else{ PUT(HDRP(bp),PACK(csize,1)); PUT(FTRP(bp),PACK(csize,1)); } } /* * mm_malloc - Allocate a block by incrementing the brk pointer. * Always allocate a block whose size is a multiple of the alignment. */ void *mm_malloc(size_t size) { size_t asize; size_t extendsize; char *bp; if(size==0) return NULL; if(size\u0026lt;=DSIZE) asize=2*DSIZE; else asize=DSIZE*((size+(DSIZE)+(DSIZE-1))/DSIZE); if((bp=find_fit(asize))!=NULL){ place(bp,asize); return bp; } extendsize=MAX(asize,CHUNKSIZE); if((bp=extend_heap(extendsize/WSIZE))==NULL) return NULL; place(bp,asize); return bp; } void *find_fit(size_t asize) { void *bp; for(bp=heap_listp;GET_SIZE(HDRP(bp))\u0026gt;0;bp=NEXT_BLKP(bp)){ if(!GET_ALLOC(HDRP(bp))\u0026amp;\u0026amp;(asize\u0026lt;=GET_SIZE(HDRP(bp)))){ //寻找第一个可以匹配的块  //heap_listp = bp; //next_fit,每次让它指向最后分配的位置就好，下次从这里匹配  return bp; } } return NULL; } /* * mm_free - Freeing a block does nothing. */ void mm_free(void *bp) { size_t size=GET_SIZE(HDRP(bp)); PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); coalesce(bp); } static void *coalesce(void *bp) { size_t prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size=GET_SIZE(HDRP(bp)); //当两边都被占用 \tif(prev_alloc \u0026amp;\u0026amp; next_alloc){ return bp; } else if(prev_alloc \u0026amp;\u0026amp;!next_alloc){//前一个被占用，后一个空闲，合并后边的 \tsize+=GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); } else if(!prev_alloc\u0026amp;\u0026amp;next_alloc){//后一个被占用，前一个空闲，合并前边的 \tsize+=GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); bp=PREV_BLKP(bp); } else{//两边都空闲，两边都合并 \tsize+=GET_SIZE(HDRP(PREV_BLKP(bp)))+GET_SIZE(FTRP(NEXT_BLKP(bp))); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(size,0)); bp=PREV_BLKP(bp); } return bp; } /* * mm_realloc - Implemented simply in terms of mm_malloc and mm_free */ void *mm_realloc(void *ptr, size_t size) { void *oldptr = ptr; void *newptr; size_t copySize; newptr = mm_malloc(size); if (newptr == NULL) return NULL; copySize = *(size_t *)((char *)oldptr - SIZE_T_SIZE); if (size \u0026lt; copySize) copySize = size; memcpy(newptr, oldptr, copySize); mm_free(oldptr); return newptr; }   ","permalink":"https://Isaray.github.io/csapp-malloclab/","tags":["CSAPP","Courses"],"title":"CSAPP:malloclab"},{"categories":["Experiments"],"contents":"CSAPP:bomblab Bomblab拆弹实录 准备工作 调试环境：  云主机Linux环境+GDB\n ssh客户端：  xshell+xftp/putty+psftp\n xshell+xftp:上传和下载文件有可视化操作界面，直接拖拽就可以上传。但是在gdb调试的时候，输入了的数据不能修改，按回车会输入^H，有的时候会手误就要重新开始。 putty+psftp：上传文件用scp命令（例如：scp hello.c xx@xxx.75.241.219/home/xx/lab0；scp -r 拷贝目录），下载文件可以用psftp。假设要下载到本地目录E:,在psftp中运行lcd E:\\定位本地目录，putty切换到云主机目录之后，get 文件名即可下载。   Linux相关命令 ：   cd document切换到文件夹; cd ..返回上一级目录;ls显示文件夹中的文件;pwd当前目录位置 解压:tar -xf all.tar，tar -zxvf filename.tar.gz cat filename 显示文件内容 vim filename查看/编辑文件内容，i进入编辑模式，esc退出编辑模式，:wq保存并退出，:q没修改直接退出。 复制文件：cp document/file newdocument/newfile 重命名：mv oldname newname   GDB调试：   进入GDB调试状态，gdb filename;或先运行gdb再运行file filename info b看断点情况；b(reak) 行号/函数名 打断点；d (elete) 行号/函数名 删除断点 i r看寄存器的值。info reg esp看%esp里存储了什么。print $eax。print (char*) $ebx。 x/s 0xffff5330 打印该地址存储的字符串；x/16x 地址 答应之后16个字节的数字。 s单步执行（不会进入被调用的函数内部），si单步执行（会进入被调用的函数内部）。c接着运行到下一个断点。 display /ni $pc。用si调试每行都会显示下一行的汇编语言。   题目求解 phase_1:地址字符串  比较字符串是否相等，查看地址中预设的字符串即可。\n phase_2:循环  读入六个数字做判断，读懂汇编语言，知道后一个数等于前两个数的加和即可。\n phase_3:switch \u0026lt;7 每个数对应一个值  是一个switch函数，输入1-7会跳转到不同的地址，和事先存入的数字进行比较。有多个答案。\n phase_4:  递归调用了func4()。首先输入的数字小于等于4。输入4，之后经过递归调用该函数得到216，最后和输入的第一个数字进行比较，所以第一个数字为216，第二个数字为4。应该有不同的答案。\n// int func4(edi ,esi,ebx){//edi last,ebx last %ebx=0x10(%esp) //8 //变成上次的eax，即7 %edi=0x14(%esp) //第二个参数 if ebx== 0 then return 0; eax=edi if ebx==1 then return eax eax=ebx-1. 从头递归。 esi=edi+eax ebx=ebx-2 从头递归。 eax=eax+esi return eax }\n phase_5:  %ebx存放字符串。 x/100x 0x804a040 看这个地址之后存放了什么。理解地址代表的含义是关键。每个输入的字符取十六进制ASCII码的后一位*4+该地址，找到对应的数字，累加到%ecx。最后%ecx要等于41。反推出要输入的字母。\n 0:02;1:a;2:6;3:1;4:c;5:0x10;6:9;7:3;8:4;9:7;10:e;11:5;12:b;13:8;14:f;15:d Prstux 2+6+1+12+16+4=41 phase_6:  读入6个数字，六个数字都\u0026lt;=6，六个数字互不相等。程序里事先存储了6个节点，六个节点有各自的编号，最后要从小到大输出，否则就爆炸。输入的6个数字代表，节点从小到大排列的顺序。\nphase_6太长了，理解了好久，做到最后还挺崩溃的，只能说大胆假设，小心求证。理解地址代表的含义同样是关键，看到node要发挥想象力。\n 5 3 2 1 4 6 0x1d5 0x325 0x391 0x1c6 0x3a5 0xef\nsecret_phase:  secret phase要触发，首先要在phase_4处多输入一个字符串DrEvil。\n首先输入的数字要小于等于1000，然后secret调用func7()，经过func7()之后必须为0。传入一个地址0x804c088，查看它就可以解开题目中预先存储的数据。整个条件判断类似二叉树的结构，要和根节点的值一致且要执行到末端，否则返回-1。又是递归。\n 这只是简要版解题思路，图片后续再补~\n解开一个要缓一缓，然后发现跟后一个phase比起来，前一个简直是小case。发现做到最后最重要的其实是心态。\n最后，有高级语言真好。\n","permalink":"https://Isaray.github.io/csapp-bomblab/","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab"},{"categories":["Experiments"],"contents":"CSAPP:datalab 代码中有具体思路的标注。 以下为实验的说明，每道题目中有规定一些运算符能否使用，使用的符号个数，并规定一些控制结构和函数不能使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  /* * CS:APP Data Lab * * * bits.c - Source file with your solutions to the Lab. * This is the file you will hand in to your instructor. * * WARNING: Do not include the \u0026lt;stdio.h\u0026gt; header; it confuses the dlc * compiler. You can still use printf for debugging without including * \u0026lt;stdio.h\u0026gt;, although you might get a compiler warning. In general, * it\u0026#39;s not good practice to ignore compiler warnings, but in this * case it\u0026#39;s OK. */ #if 0Each \u0026#34;Expr\u0026#34; is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; Some of the problems restrict the set of allowed operators even further. Each \u0026#34;Expr\u0026#34; may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as \u0026amp;\u0026amp;, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting an integer by more than the word size. EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 \u0026lt;\u0026lt; x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 \u0026lt;\u0026lt; x); result += 4; return result; } FLOATING POINT CODING RULES For the problems that require you to implent floating-point operations, the coding rules are less strict. You are allowed to use looping and conditional control. You are allowed to use both ints and unsigneds. You can use arbitrary integer and unsigned constants. You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants. NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operators (! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt;) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that \u0026#39;=\u0026#39; is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source.   以下为所需要写的函数，每个函数的说明和限制都在注释中有具体讲解。\n1.bitAnd ：  不用\u0026amp;，而用|表示\u0026amp;。两者像照镜子，\u0026amp;是同1则1，|是同0则0，用德摩根律，一反再反刚好对称过来。\n 1 2 3 4 5 6 7 8 9 10 11  /* * bitAnd - x\u0026amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */ int bitAnd(int x, int y) { /*It\u0026#39;s equal to find the position that both are 0 and find its reversed version.有点像德摩根律。*/ return ~(~x|~y); }   2.getByte:  先算数左移再算数右移，再减去算数右移增加的补位数\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 6 * Rating: 2 */ int getByte(int x, int n) { /*先算数左移再算数右移，再减去算数右移增加的补位数*/ int t,t1,t2; t1=x\u0026lt;\u0026lt;((3-n)*2*4); t2=t1\u0026gt;\u0026gt;7*4\u0026gt;\u0026gt;4\u0026lt;\u0026lt;(2*4); t=(t1\u0026gt;\u0026gt;(6*4))-t2; return t; }   3.logicalShift:  找出最高位的符号，然后把算数右移前面补的位数减掉即可 ~n+1相当于-n 0xffffffff相当于-1\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 \u0026lt;= n \u0026lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 20 * Rating: 3 */ int logicalShift(int x, int n) { /*找出最高位的符号，然后把算数右移前面补的位数减掉即可*/ int t; t=x\u0026gt;\u0026gt;31\u0026lt;\u0026lt;(32+(~n+1)+0xffffffff)\u0026lt;\u0026lt;1; t=(x\u0026gt;\u0026gt;n)\u0026amp;(~t); //这里用了一个mask小技巧，\u0026amp;mask为1的位置就会显露出来  return t; }   4.bitCount:  原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /* * bitCount - returns count of number of 1\u0026#39;s in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 40 * Rating: 4 */ int bitCount(int x) { /*difficult*/ /*原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！*/ int mask1=0x55555555;//01(循环至32位)01010101  int mask2=0x33333333;//0011(循环至32位)  int mask3=0x0f0f0f0f;//00001111(循环至32位)  int mask4=0x00ff00ff;//0000000011111111(循环至32位)  int mask5=0x0000ffff;//00000000000000001111111111111111  int t; t=(x\u0026amp;mask1)+((x\u0026gt;\u0026gt;1)\u0026amp;mask1); t=(t\u0026amp;mask2)+((t\u0026gt;\u0026gt;2)\u0026amp;mask2); t=(t\u0026amp;mask3)+((t\u0026gt;\u0026gt;4)\u0026amp;mask3); t=(t\u0026amp;mask4)+((t\u0026gt;\u0026gt;8)\u0026amp;mask4); t=(t\u0026amp;mask5)+((t\u0026gt;\u0026gt;16)\u0026amp;mask5); return t; }   5.bang:  利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。\n 1 2 3 4 5 6 7 8 9 10 11  /* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ int bang(int x) { /*利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。*/ return ((x|(~x+1))\u0026gt;\u0026gt;31)+1 ; }   6.tmin:  很简单。根据定义即可。\n 1 2 3 4 5 6 7 8 9  /* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1\u0026lt;\u0026lt;31; }   7.fitsBits:  就是用两种不同方式去解读，判断能不能表示成n位有符号数。 第n位和第n位之前的位数的数字应该都相同，否则就无法表示。判断是否相同用按位与的方式。\n 1 2 3 4 5 6 7 8 9 10 11 12 13  /* * fitsBits - return 1 if x can be represented as an * n-bit, two\u0026#39;s complement integer. * 1 \u0026lt;= n \u0026lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int fitsBits(int x, int n) { /*第n位和第n位之前的位数的数字应该都相同，否则就无法表示。*/ return !((x\u0026lt;\u0026lt;(32-n)\u0026gt;\u0026gt;(32-n))^x); }   8.divpwr2:  非整除情况，如果是负数的话，x\u0026raquo;n结果要加一(n非0)。对于对于负数~(x\u0026raquo;31)=0。整除情况如常。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * divpwr2 - Compute x/(2^n), for 0 \u0026lt;= n \u0026lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int divpwr2(int x, int n) { /*非整除情况，如果是负数的话，x\u0026gt;\u0026gt;n结果要加一(n非0)。对于对于负数~(x\u0026gt;\u0026gt;31)=0。整除情况如常。*/ int s=!!(x\u0026gt;\u0026gt;31); int t=!!((x\u0026lt;\u0026lt;(32+~n+1))^0); return (x\u0026gt;\u0026gt;n)+(s\u0026amp;t\u0026amp;!!n); }   9.negate:  因为 ~x+x=0xffffffff且0xffffffff=-1。所以-x= ~x+1。\n 1 2 3 4 5 6 7 8 9 10  /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; }   10.isPositive:  x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。\n 1 2 3 4 5 6 7 8 9 10 11  /* * isPositive - return 1 if x \u0026gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 8 * Rating: 3 */ int isPositive(int x) { /*x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。*/ return !(x\u0026gt;\u0026gt;31)\u0026amp;!!x; }   11.isLessOrEqual:  即y-x\u0026gt;=0或y\u0026gt;0,x\u0026lt;0(若溢出)。分类讨论。（y\u0026gt;0,x\u0026gt;0,y-x\u0026gt;0）|（y\u0026gt;0,x\u0026lt;0）|（y\u0026lt;0,x\u0026lt;0,y-x\u0026gt;0）\n 1 2 3 4 5 6 7 8 9 10 11  /* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { /*即y-x\u0026gt;=0或y\u0026gt;0,x\u0026lt;0(若溢出)。分类讨论。*/ return (!(y\u0026gt;\u0026gt;31)\u0026amp;!(x\u0026gt;\u0026gt;31)\u0026amp;!((y+~x+1)\u0026gt;\u0026gt;31))|((!(y\u0026gt;\u0026gt;31))\u0026amp;(x\u0026gt;\u0026gt;31))|((y\u0026gt;\u0026gt;31)\u0026amp;(x\u0026gt;\u0026gt;31)\u0026amp;!((y+~x+1)\u0026gt;\u0026gt;31)); }   12.ilog2:  找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * ilog2 - return floor(log base 2 of x), where x \u0026gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ int ilog2(int x) { /*找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！*/ int t; t=(!!(x\u0026gt;\u0026gt;16))\u0026lt;\u0026lt;4; t=t+((!!(x\u0026gt;\u0026gt;(8+t)))\u0026lt;\u0026lt;3); t=t+((!!(x\u0026gt;\u0026gt;(4+t)))\u0026lt;\u0026lt;2); t=t+((!!(x\u0026gt;\u0026gt;(2+t)))\u0026lt;\u0026lt;1); t=t+(!!(x\u0026gt;\u0026gt;(1+t))); return t; }   13.float_neg:  判断是否为NaN，然后最高位取反。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 10 * Rating: 2 */ unsigned float_neg(unsigned uf) { /*判断是否为NaN，然后最高位取反。*/ unsigned exp=(uf\u0026amp;0x7ff80000)\u0026gt;\u0026gt;23;//011111111100000000000000000000000  unsigned frac=uf\u0026amp;0x7fffff;//00000000011111111111111111111111  if(!(exp^0xff) \u0026amp;\u0026amp; !!(frac^0) )//exp=0xff且frac!=0 \treturn uf;//为NaN返回NaN  return uf^0x80000000;//s位变号即可  }   14.float_i2f:  主要看次数+要不要进位 32-i-1+127即exp flag是看要不要进位\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned i=0,t; unsigned s=(!!(x\u0026gt;\u0026gt;31))\u0026lt;\u0026lt;31; if(!(x^0)) return 0;//为0则0  if(!(x^0x80000000)) return 0xcf000000;//-2^31  if(s) x=~x+1;//负数转换成正数  while(!((x\u0026lt;\u0026lt;i)\u0026amp;0x80000000)){//高位不为1就循环  i=i+1; } t=(x\u0026lt;\u0026lt;i)-0x80000000; int flag=0;//若进位，flag变成1  if((t\u0026amp;0xff)\u0026gt;0x80) flag=1; else{ if((t\u0026amp;0x180)==0x180) flag=1; } t=t\u0026gt;\u0026gt;8; t=s+((32-i-1+127)\u0026lt;\u0026lt;23)+t+flag;//32-i-1+127即exp  return t; }   15.float_twice:  denormalized 的浮点数,exp全为0，乘以2只需将frac左移一位并保持符号不变 normalized 的浮点数，乘以2只需exp++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { unsigned exp=(uf\u0026amp;0x7ff80000)\u0026gt;\u0026gt;23;//011111111100000000000000000000000  unsigned frac=uf\u0026amp;0x7fffff;//00000000011111111111111111111111  unsigned t; if(!(exp^0xff) ){ return uf;//NaN  } int k=!!(uf\u0026amp;0x7fffffff)\u0026amp;!!exp; t=(uf\u0026amp;0x80000000)+((exp+k)\u0026lt;\u0026lt;23)+(frac\u0026lt;\u0026lt;!exp);//s+exp+frac//exp全0的，frac\u0026lt;\u0026lt;1,exp不变;否则exp++  return t; }   结果： ./btest\n","permalink":"https://Isaray.github.io/csapp-datalab/","tags":["CSAPP","Courses"],"title":"CSAPP:datalab"},{"categories":null,"contents":"CJ Lei\nA student major in data science and engineering.\nLet\u0026rsquo;s listen to some music!\n ","permalink":"https://Isaray.github.io/about/","tags":null,"title":"About Me"},{"categories":null,"contents":"","permalink":"https://Isaray.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"https://Isaray.github.io/search/","tags":null,"title":"Search"}]