[{"categories":["Notes","Books"],"contents":"浪潮之巅阅读笔记 在两年前就曾经读过吴军老师的《数学之美》，吴军老师的学识、眼界和文字功底给我留下了深刻的印象，心中非常敬仰。在学校的课程学习中，也有三个老师都不约而同地提到过这门书，推荐作为课外读物。重读《数学之美》也该提上日程了。\n不过，之前一直想读吴军老师的其他书，久闻《浪潮之巅》大名，但是图书馆里的基本几乎都被借走了，也就没有继续看下去。这次开学终于借到了《浪潮之巅》，希望能够边读边做一些笔记。\nAT\u0026amp;T AT\u0026amp;T（美国电话电报公司），于1877年由亚历山大·贝尔（Alexander Bill）创建，1925年成立了著名的研发机构贝尔实验室（Bell Laboratories）。贝尔实验室有很多除了电话以外闻名于世的发明，包括射电天文望远镜、晶体管、数字交换机、计算机的Unix操作系统和C语言，发现了电子的波动性，提出了信息论，组织发射了第一颗商用通信卫星，铺设了第一条商用光纤。\n1984年在反垄断法的要求下，AT\u0026amp;T按地区划分出去7家小贝尔（Baby Bells）。\n作者指出反垄断法并没有导致AT\u0026amp;T的衰弱，利令智昏和互联网的兴起才是AT\u0026amp;T衰弱的原因。\n1995年达到AT\u0026amp;T公司的顶峰，但是在接下来短短十年之间分崩离析。\n1996年分离成AT\u0026amp;T、朗讯和NCR三家公司。贝尔实验室也被一分为二，朗讯的那一半沿用了贝尔实验室的命长，AT\u0026amp;T实验室后更名为香农实验室（Shannon Labs）。\nAT\u0026amp;T不断地被拆分上市，华尔街的投资者、股权持有者在短线投资上获得了巨大的利益，而公司却走向了深渊。另外加上互联网的兴起，可替代的实时通讯方式增多，而电话业务需求量变少。最后被自己分离的子公司SBC收购，后被法国的阿尔卡特并购，AT\u0026amp;T从此消亡。为了撑高股价，朗讯在互联网泡沫经济年代借钱给各个公司来购买朗讯设备，只要设备被运出就会计入季度的销售额，后来借钱买设备的公司纷纷倒闭，应收款项全部都变成了净亏损。\n一些印象深刻的话：\n花旗银行的以为由20年资本管理经验的副总裁对我讲，评价一个上市公司的还坏，其实只要看哪些最优秀的人是流进这家公司的，还是流出这家公司的即可。（想到之前听朋友说的李航去了字节的消息，一查还是2017年的事）\n另外，1972年，Unix操作系统和c语言诞生于贝尔实验室。\nIBM 蓝色巨人IBM自1924以来屹立百年。\nApple","permalink":"https://Isaray.github.io/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["IT","History"],"title":"浪潮之巅阅读笔记"},{"categories":["Notes"],"contents":"Zotero\nZotero是一款开源文献管理软件，功能和EndNote相似，但是其丰富的插件使其具有十分强大的功能。\n到官网（Zotero | Downloads）下载对应版本的Zotero和浏览器插件。\n按照网上教程安装Zotero插件，参考连接如下：\nZotero的插件介绍 - 知乎 (zhihu.com)\n安装quicklook后点击空格就可以预览。\nZotero网盘同步及文件夹重命名 - 知乎 (zhihu.com)\n所有文件都存储到了onedrive的文件夹下。\n下载坚果云客户端，配置文件夹可以达到同样的效果。\n","permalink":"https://Isaray.github.io/zotero/","tags":["Tools"],"title":"Zotero的使用"},{"categories":["Tutorial"],"contents":"Build our own website by using Hugo on Wins Hugo is said to be the world\u0026rsquo;s fastest framework for building websites.\nThe world’s fastest framework for building websites | Hugo (gohugo.io)\nInstall Hugo There are so many tutorials for installing hugo on macOS and Linux, and this blog mainly fucuses on how to install hugo on Windows.\nAnd I recommend using method two.\nMethod One： Using Official Docs Hugo official installation file：\nInstall Hugo | Hugo (gohugo.io)\nFirst, make sure you have chocolatey on your laptop with Windows system.\n1. Install chocolatey on Windows Chocolatey Software Docs | Setup / Install\n Please remember to start a command prompt as an administrator.\n run the following command:\n1  @\u0026#34;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#34; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \u0026#34;[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET \u0026#34;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\u0026#34;   Check whether hugo is installed successfully with the following command:\n1  choco help   2.Install Hugo with Chocolatey\nIf you are on a Windows machine and use Chocolatey for package management, you can install Hugo with the following one-liner:\ninstall-with-chocolatey.ps1\n1  choco install hugo -confirm   Or if you need the “extended” Sass/SCSS version:\ninstall-extended-with-chocolatey.ps1\n1  choco install hugo-extended -confirm   Method Two：Download hugo.exe directly 1.Download Hugo Releases · gohugoio/hugo (github.com)\n Download the certain version you need. Some website themes have requirements of hugo version.\n 2. Set Environment Variables Set the folder of hugo.exe as environment variables.\nThen, open another command line to check whether it is successfully set or not. Run the command in CMD:\nhugo version\nThemes I Prefered There are many themes on the official websites.\nComplete List | Hugo Themes (gohugo.io)\nPersonally I prefered the following themes.\nAcademic | Hugo Themes (gohugo.io)\nAcademic | Hugo Themes (gohugo.io)\nPaperMod | Hugo Themes (gohugo.io)\nEven | Hugo Themes (gohugo.io)\nTranquilpeak | Hugo Themes (gohugo.io)\nClean White | Hugo Themes (gohugo.io)\nLoveIt | Hugo Themes (gohugo.io)\nI use the theme LoveIt.\nLoveIt (hugoloveit.com)\nInstall it according to the official document and try to build demo yourself.\nTheme Documentation - Basics - LoveIt (hugoloveit.com)\nYou can also follow the steps in this video. Although it is on the MacOS system, she explained everything clearly in Chinese.\nHugo - 10分钟搭建 \u0026amp; 部署个人网站/博客，简历中的博客网站怎么建哔哩哔哩bilibili\n Memos Important Command 1.hugo serve Executehugo serve under the root folder of the project, click http://localhost:1313/ to visit your website locally.\n2.hugo  make sure that in the config.toml , it is written like baseUrl=\u0026ldquo;https://[username].github.io\u0026rdquo; Executehugo under the root folder of the project. For the first time you do it, the public folder will be made. If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo.  Publish on GitHub Pages   new a repository，setting it to public。\n  Set the address of your blog [username].github.io at setting/pages. Set the branch to master if you use it.\n  Executehugo under the root folder of the project. For the first time you do it, the public folder will be made.(make sure that in the config.toml , it is written like baseUrl=\u0026ldquo;https://[username].github.io\u0026rdquo;)\ncd public, run the command:\n1 2 3 4 5  git init git add . git commit -m\u0026#34;first commit\u0026#34; git add remote origin \u0026#34;your reposotory address\u0026#34; git push -u origin master     Wait a few minites，and you can visit your website on https://[username].github.io.\ntips:\n If the your website doesn\u0026rsquo;t change after a sucessful push, please check the actions of repository. The compiling of new github pages probably failed.\n  If there is any mistake when compiling, it is recomended to delete all files in the public folder before execute hugo.\n Some mistakes I met If the style/css of the website went wrong, you should check the url and address in index.html page. Perhaps the baseUrl is wrong.\nThe Extended Functions of LoveIt： Hugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 - Yulin Lewis' Blog (lewky.cn)\nThere are four blogs in the link , including the improvements of searching！\nThe official link is also helpful.\nTheme Documentation - Extended Shortcodes - LoveIt (hugoloveit.com)\nSave My config.toml I revise the config.toml according to the offical demo and files,\nincluding:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;xxx\u0026#34; [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.png\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;xxx\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;这是我的全新 Hugo 网站\u0026#34; # 是否保持使用文章前面的静态目录 keepStatic = false [params.list] # list 页面每页显示文章数量 paginate = 10 ...   Here is my config.toml\nI delete the function of comments, because it goes wrong on github pages.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535  baseURL = \u0026#34;https://xxx.github.io/\u0026#34; # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \u0026#34;en\u0026#34; # language code languageCode = \u0026#34;en\u0026#34; title = \u0026#34;xxx\u0026#39;s blog\u0026#34; # Change the default theme to be use when building the site with Hugo theme = [\u0026#34;hugo-search-fuse-js\u0026#34;,\u0026#34;LoveIt\u0026#34;] # whether to use emoji code # 是否使用 emoji 代码 enableEmoji = true [menu] [[menu.main]] identifier = \u0026#34;posts\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons pre = \u0026#34;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons post = \u0026#34;\u0026#34; name = \u0026#34;Posts\u0026#34; url = \u0026#34;/posts/\u0026#34; # title will be shown when you hover on this menu link title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;projects\u0026#34; # you can add extra information before the name (HTML format is supported), such as icons pre = \u0026#34;\u0026#34; # you can add extra information after the name (HTML format is supported), such as icons post = \u0026#34;\u0026#34; name = \u0026#34;Projects\u0026#34; url = \u0026#34;/categories/projects/\u0026#34; # title will be shown when you hover on this menu link title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Tags\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;Categories\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; weight = 3 [[menu.main]] identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;About\u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; weight = 5 [[menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;search\u0026#34; weight = 7 identifier = \u0026#34;search\u0026#34; url = \u0026#34;/search/\u0026#34; [params] # LoveIt 主题版本 version = \u0026#34;0.2.X\u0026#34; # 网站描述 description = \u0026#34;这是我的全新 Hugo 网站\u0026#34; # 网站关键词 keywords = [\u0026#34;Theme\u0026#34;, \u0026#34;Hugo\u0026#34;] # 网站默认主题样式 (\u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;, \u0026#34;auto\u0026#34;) defaultTheme = \u0026#34;auto\u0026#34; # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \u0026#34;\u0026#34; # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\u0026#34;sha256\u0026#34;, \u0026#34;sha384\u0026#34;, \u0026#34;sha512\u0026#34;, \u0026#34;md5\u0026#34;) fingerprint = \u0026#34;\u0026#34; # 日期格式 dateFormat = \u0026#34;2006-01-02\u0026#34; # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\u0026#34;/logo.png\u0026#34;] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;LoveIt\u0026#34; # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#34;\u0026#34; # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-10磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; # 搜索配置 [params.search] enable = false # 搜索引擎的类型 (\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;) type = \u0026#34;lunr\u0026#34; # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \u0026#34;\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) desktopMode = \u0026#34;fixed\u0026#34; # 移动端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) mobileMode = \u0026#34;auto\u0026#34; # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;Isaray\u0026#39;s blog\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = \u0026#39;\u0026#39; # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \u0026#34;\u0026#34; # 许可协议信息 (支持 HTML 格式) license = \u0026#39;\u0026lt;a rel=\u0026#34;license external nofollow noopener noreffer\u0026#34; href=\u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;CC BY-NC 4.0\u0026lt;/a\u0026gt;\u0026#39; # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 10 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 10 # 日期格式 (月和日) dateFormat = \u0026#34;01-02\u0026#34; # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.png\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;xxx\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;A student major in Data Science and Engineering.\u0026#34; # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \u0026#34;hiddenFromHomePage\u0026#34; 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \u0026#34;https://github.com/Isaray\u0026#34; Linkedin = \u0026#34;xxxx\u0026#34; Twitter = \u0026#34;\u0026#34; Instagram = \u0026#34;xxxx\u0026#34; Facebook = \u0026#34;\u0026#34; Telegram = \u0026#34;xxxx\u0026#34; Medium = \u0026#34;\u0026#34; Gitlab = \u0026#34;\u0026#34; Youtubelegacy = \u0026#34;\u0026#34; Youtubecustom = \u0026#34;\u0026#34; Youtubechannel = \u0026#34;\u0026#34; Tumblr = \u0026#34;\u0026#34; Quora = \u0026#34;\u0026#34; Keybase = \u0026#34;\u0026#34; Pinterest = \u0026#34;\u0026#34; Reddit = \u0026#34;\u0026#34; Codepen = \u0026#34;\u0026#34; FreeCodeCamp = \u0026#34;\u0026#34; Bitbucket = \u0026#34;\u0026#34; Stackoverflow = \u0026#34;\u0026#34; Weibo = \u0026#34;\u0026#34; Odnoklassniki = \u0026#34;\u0026#34; VK = \u0026#34;\u0026#34; Flickr = \u0026#34;\u0026#34; Xing = \u0026#34;\u0026#34; Snapchat = \u0026#34;\u0026#34; Soundcloud = \u0026#34;\u0026#34; Spotify = \u0026#34;\u0026#34; Bandcamp = \u0026#34;\u0026#34; Paypal = \u0026#34;\u0026#34; Fivehundredpx = \u0026#34;\u0026#34; Mix = \u0026#34;\u0026#34; Goodreads = \u0026#34;\u0026#34; Lastfm = \u0026#34;\u0026#34; Foursquare = \u0026#34;\u0026#34; Hackernews = \u0026#34;\u0026#34; Kickstarter = \u0026#34;\u0026#34; Patreon = \u0026#34;\u0026#34; Steam = \u0026#34;\u0026#34; Twitch = \u0026#34;\u0026#34; Strava = \u0026#34;\u0026#34; Skype = \u0026#34;\u0026#34; Whatsapp = \u0026#34;\u0026#34; Zhihu = \u0026#34;\u0026#34; Douban = \u0026#34;\u0026#34; Angellist = \u0026#34;\u0026#34; Slidershare = \u0026#34;\u0026#34; Jsfiddle = \u0026#34;\u0026#34; Deviantart = \u0026#34;\u0026#34; Behance = \u0026#34;\u0026#34; Dribbble = \u0026#34;\u0026#34; Wordpress = \u0026#34;\u0026#34; Vine = \u0026#34;\u0026#34; Googlescholar = \u0026#34;\u0026#34; Researchgate = \u0026#34;\u0026#34; Mastodon = \u0026#34;\u0026#34; Thingiverse = \u0026#34;\u0026#34; Devto = \u0026#34;\u0026#34; Gitea = \u0026#34;\u0026#34; XMPP = \u0026#34;\u0026#34; Matrix = \u0026#34;\u0026#34; Bilibili = \u0026#34;\u0026#34; Email = \u0026#34;xxxx@xxxx.com\u0026#34; RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前面的静态目录 #修改为动态 keepStatic = false # 是否使侧边目录自动折叠展开 auto = true # 代码配置 [params.page.code] # 是否显示代码块的复制按钮 copy = true # 默认展开显示的代码行数 maxShownLines = 10 # KaTeX 数学公式 [params.page.math] enable = true # 默认块定界符是 $$ ... $$ 和 \\\\[ ... \\\\] blockLeftDelimiter = \u0026#34;\u0026#34; blockRightDelimiter = \u0026#34;\u0026#34; # 默认行内定界符是 $ ... $ 和 \\\\( ... \\\\) inlineLeftDelimiter = \u0026#34;\u0026#34; inlineRightDelimiter = \u0026#34;\u0026#34; # KaTeX 插件 copy_tex copyTex = true # KaTeX 插件 mhchem mhchem = true # Mapbox GL JS 配置 [params.page.mapbox] # Mapbox GL JS 的 access token accessToken = \u0026#34;\u0026#34; # 浅色主题的地图样式 lightStyle = \u0026#34;mapbox://styles/mapbox/light-v9\u0026#34; # 深色主题的地图样式 darkStyle = \u0026#34;mapbox://styles/mapbox/dark-v9\u0026#34; # 是否添加 NavigationControl navigation = true # 是否添加 GeolocateControl geolocate = true # 是否添加 ScaleControl scale = true # 是否添加 FullscreenControl fullscreen = true # 文章页面的分享信息设置 [params.page.share] enable = true Twitter = true Facebook = true Linkedin = false Whatsapp = true Pinterest = false Tumblr = false HackerNews = false Reddit = false VK = false Buffer = false Xing = false Line = true Instapaper = false Pocket = false Digg = false Stumbleupon = false Flipboard = false Weibo = true Renren = false Myspace = true Blogger = true Baidu = false Odnoklassniki = false Evernote = true Skype = false Trello = false Mix = false # 第三方库配置 [params.page.library] [params.page.library.css] # someCSS = \u0026#34;some.css\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someCSS = \u0026#34;https://cdn.example.com/some.css\u0026#34; [params.page.library.js] # someJavascript = \u0026#34;some.js\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someJavascript = \u0026#34;https://cdn.example.com/some.js\u0026#34; # 页面 SEO 配置 [params.page.seo] # 图片 URL images = [] # 出版者信息 [params.page.seo.publisher] name = \u0026#34;\u0026#34; logoUrl = \u0026#34;\u0026#34; # TypeIt 配置 [params.typeit] # 每一步的打字速度 (单位是毫秒) speed = 100 # 光标的闪烁速度 (单位是毫秒) cursorSpeed = 1000 # 光标的字符 (支持 HTML 格式) cursorChar = \u0026#34;|\u0026#34; # 打字结束之后光标的持续时间 (单位是毫秒, \u0026#34;-1\u0026#34; 代表无限大) duration = -1 # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [params.verification] google = \u0026#34;\u0026#34; bing = \u0026#34;\u0026#34; yandex = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; baidu = \u0026#34;\u0026#34; # 网站 SEO 配置 [params.seo] # 图片 URL image = \u0026#34;\u0026#34; # 缩略图 URL thumbnailUrl = \u0026#34;\u0026#34; # 网站分析配置 [params.analytics] enable = false # Google Analytics [params.analytics.google] id = \u0026#34;\u0026#34; # 是否匿名化用户 IP anonymizeIP = true # Fathom Analytics [params.analytics.fathom] id = \u0026#34;\u0026#34; # 自行托管追踪器时的主机路径 server = \u0026#34;\u0026#34; # Cookie 许可配置 [params.cookieconsent] enable = true # 用于 Cookie 许可横幅的文本字符串 [params.cookieconsent.content] message = \u0026#34;\u0026#34; dismiss = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # 第三方库文件的 CDN 设置 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\u0026#34;jsdelivr.yml\u0026#34;) # 位于 \u0026#34;themes/LoveIt/assets/data/cdn/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/data/cdn/\u0026#34; data = \u0026#34;\u0026#34; # 兼容性设置 [params.compatibility] # 是否使用 Polyfill.io 来兼容旧式浏览器 polyfill = false # 是否使用 object-fit-images 来兼容旧式浏览器 objectFit = false # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 # 作者配置 [author] name = \u0026#34;Isaray\u0026#34; email = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # 网站地图配置 [sitemap] changefreq = \u0026#34;weekly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 # Permalinks 配置 [Permalinks] # posts = \u0026#34;:year/:month/:filename\u0026#34; posts = \u0026#34;:filename\u0026#34; # 隐私信息配置 [privacy] # Google Analytics 相关隐私 (被 params.analytics.google 替代) [privacy.googleAnalytics] # ... [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\u0026#34;text/plain\u0026#34;] suffixes = [\u0026#34;md\u0026#34;] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \u0026#34;text/plain\u0026#34; isPlainText = true isHTML = false # 用于 Hugo 输出文档的设置 [outputs] # home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] page = [\u0026#34;HTML\u0026#34;, \u0026#34;MarkDown\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;]   ","permalink":"https://Isaray.github.io/build_websites_with_hugo/","tags":["Hugo","Installation"],"title":"How to build our own websites with Hugo on Windows?"},{"categories":["Notes"],"contents":"1.递归 1.1算法策略 把问题分解成更小规模的同类子问题，用递归调用的方法求解问题。\n1.2 适用场景 引用知乎一篇文章的总结\n递归算法一般用于解决三类问题：\n 数据的定义是按递归定义的。（斐波那契数列） 问题解法按递归算法实现。（回溯） 数据的结构形式是按递归定义的。（树的遍历，图的搜索）  解题策略 （1）明确输入输出\n（2）明确递归结束条件\n（3）明确递归关系式\n1.3经典问题  斐波那契数列 汉诺塔问题 树的遍历及相关操作  2.分治 2.1算法策略 将一个问题分解成多个子问题，每个子问题又可以分解成更小的子问题，直到子问题可以被求解。原问题是子问题的合并。\n2.2适用场景 当出现满足以下条件的问题，可以尝试只用分治策略进行求解：\n 原始问题可以分成多个相似的子问题 子问题可以很简单的求解 原始问题的解是子问题解的合并 各个子问题是相互独立的，不包含相同的子问题  解题策略  分解大问题 解决子问题 合并子问题结果  2.3经典问题  二分查找 归并排序 快速排序 汉诺塔问题 React 时间分片  3.贪心 3.1算法策略 总是选择当下最优的解决方案。\n3.2适用场景 当满足一下条件时，可以使用：\n 原问题复杂度过高 求全局最优解的数学模型难以建立或计算量过大 没有太大必要一定要求出全局最优解，“比较优”就可以  解题策略  定义最优解条件 把问题分解成多个步骤，每一步要满足  可行性：每一步都满足问题的约束 局部最优 不可取消    最后叠加所有步骤得到最优解。\n3.3经典问题 使用贪心算法求解的经典问题有：\n 最小生成树算法 单源最短路径的 Dijkstra 算法 Huffman 压缩编码 背包问题 活动选择问题等  4.回溯 4.1算法策略 步步尝试，不行回退。\n4.2适用场景 不断的尝试，直到拿到解。从一组可能的解中，选择一个满足要求的解。\n4.3经典问题  深度优先搜索 0-1背包问题 正则表达式匹配 八皇后 数独 全排列  5.动态规划 5.1算法策略 Taking notes.\n将复杂问题分解成小问题求解，各个子问题之间有重合，结果可以复用。\n5.2适用场景 求解最优解。\n解题策略 需要遵循以下几个重要步骤：\n 定义子问题 实现需要反复执行解决的子子问题部分 识别并求解出边界条件  5.3经典问题  爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）  6.枚举 6.1算法策略 一一列举，明确列举范围。\n6.3经典问题 参考：\n95% 的算法都是基于这 6 种算法思想！！！ - 知乎 (zhihu.com)\nBAT机器学习面试1000题系列_HuangQinJian-CSDN博客_bat机器学习1000题\n剑指offer-Python版（上） - 知乎 (zhihu.com)\n1.bfs,dfs dfs可以看作不知道层数情况下的枚举法，用到递归的思想。\n回溯算法，先列举出来再还原。\n全排列\n1 2 3 4 5 6 7 8 9 10 11  class Solution2: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: res = [] def backtrack(nums, tmp): if not nums: res.append(tmp) return for i in range(len(nums)): backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]]) backtrack(nums, []) return res   岛屿数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def numIslands(self, grid): row, col, ret = len(grid), len(grid[0]), 0 def dfs(x, y): grid[x][y] = \u0026#39;0\u0026#39; for c in [[0, 1], [0, -1], [1, 0], [-1, 0]]: nx, ny = x + c[0], y + c[1] if 0 \u0026lt;= nx \u0026lt; row and 0 \u0026lt;= ny \u0026lt; col and grid[nx][ny] == \u0026#39;1\u0026#39;: dfs(nx, ny) for i in range(row): for j in range(col): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(i, j) ret += 1 return ret   2.binary search 求x的平方根\n1 2 3 4 5 6 7 8 9 10 11  class Solution: def mySqrt(self, x: int) -\u0026gt; int: l, r, ans = 0, x, -1 while l \u0026lt;= r: mid = (l + r) // 2 if mid * mid \u0026lt;= x: ans = mid l = mid + 1 else: r = mid - 1 return ans   3.sliding window move them simutanously 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。\n示例 1:\n输入: s = \u0026ldquo;abcabcbb\u0026rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\n1 2 3 4 5 6 7 8 9  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: cur, res = [], 0 for r in range(len(s)): while s[r] in cur: cur.pop(0) # 左边出 cur.append(s[r]) # 右侧无论如何都会进入新的 res = max(len(cur),res) return res   recursion\nfibonacci, binary tree\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def hanota(self, A: List[int], B: List[int], C: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify C in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(A) self.move(n, A, B, C) def move(self, n, A, B, C): if n == 1: C.append(A.pop()) else: self.move(n-1, A, C, B) C.append(A.pop()) self.move(n-1, B, A, C)   inverting into binary tree\nreverse a linked list\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution(object): def reverseList(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; # 申请两个节点，pre和 cur，pre指向None pre = None cur = head # 遍历链表，while循环里面的内容其实可以写成一行 # 这里只做演示，就不搞那么骚气的写法了 while cur: # 记录当前节点的下一个节点 tmp = cur.next # 然后将当前节点指向pre cur.next = pre # pre和cur节点都前进一位 pre = cur cur = tmp return pre   suffix trees\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Trie: def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix: str) -\u0026gt; \u0026#34;Trie\u0026#34;: node = self for ch in prefix: ch = ord(ch) - ord(\u0026#34;a\u0026#34;) if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word: str) -\u0026gt; None: node = self for ch in word: ch = ord(ch) - ord(\u0026#34;a\u0026#34;) if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word: str) -\u0026gt; bool: node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix: str) -\u0026gt; bool: return self.searchPrefix(prefix) is not None   heaps\nrepeatedly find min,max\n第 k 个最大的元素\n1 2 3 4 5 6 7 8 9 10 11  class Solution: def findKthLargest(self, nums: List[int], k: int) -\u0026gt; int: # 构造大小为 k 的小顶堆 heap = [x for x in nums[:k]] heapq.heapify(heap) n = len(nums) for i in range(k, n): if nums[i] \u0026gt; heap[0]: heapq.heappop(heap) heapq.heappush(heap, nums[i]) return heap[0]   dynamic programming\nsorting algorithm\nquick sort and merge sort\n","permalink":"https://Isaray.github.io/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/","tags":["Python","Algorithm"],"title":"六种常见算法"},{"categories":["Courses"],"contents":"算法导论【复习】 教材：算法导论第三版\n本博客内容均为自行整理，以供学过算法的同学快速回忆之用。\n本人第一篇博客，当然要献给算法啦！博客是在复习的时候整理的，有点类似于记忆碎片，比较简略，欢迎大家在评论区讨论、补充、纠正。 ](算法导论期末复习大纲)\n【算法复杂度】： 假设所需计算机资源的量只和问题规模、算法输入和算法本身的函数相关。\n时间复杂度： 用基本操作步数衡量，独立于机器。 在不同情况下算法复杂度也是不同的，常见的情况有最好情况下，平均情况下，最坏情况下的时间复杂度。\n首先，是时间复杂度的三个概念O(),$\\theta$(),$\\omega$()。\n【算法导论】P26，三张图有助于理解\n- $O$() 渐进上界  {f(n):存在正常量c,$n_0$，使得对所有n\u0026gt;=$n_0$，有0\u0026lt;=f(n)\u0026lt;=cg(n)}\n - $\\theta$() 渐进紧确界  {f(n):存在正常量$c_1$、$c_2$和$n_0$，使得对所有n\u0026gt;=$n_0$，有0\u0026lt;=$c_1$g(n)\u0026lt;=f(n)\u0026lt;=$c_2$g(n)}\n - $\\Omega$() 渐进下界  {f(n):存在正常量c,$n_0$，使得对所有n\u0026gt;=$n_0$，有0\u0026lt;=cg(n)\u0026lt;=f(n)}\n  另外：\n1.$\\omicron$()代表非渐进紧确上界，$\\omega$()代表非渐进紧确下界。o(g(n)) = {f(n): 对任意正常数c\u0026gt;0，使得对所有n\u0026gt;=$n_0$，有0\u0026lt;=f(n)\u0026lt;cg(n)}\n2.$O()$和$\\Omega$()如果非常紧的话都会趋向于$\\theta$()。（有一种紧确界的证明方式就是这样的）\n3.$O()$往往差了些也是对的，但是不准确，比如用O($n^{100}$)来描述快速排序的平均时间复杂度也是对的,但是不如O(nlogn)来得确切。所以比较紧的界才有意义，能求出$\\theta$()最好啦。（另外，用$o(nlogn)$来描述快速排序的平均情况就不行，因为$\\omicron$()代表非渐进紧确上界，看那个定义中是没有等号的，要注意大O和小o的区别）。\n 根据递归式求$O$()和 $\\Omega$()的三种方法：  代入法P48：猜测复杂度式子，假设出来（可能需要带低阶的参数），代入递归式并证明。 递归树法P50：把递归树画出来，然后累加（可能会用到级数相关知识）。那种分成两颗不均匀子树的情况常用这种方法求解。 主方法P53：可以用递归树法推导，推导过程中会用到$n^{log_ba} = a^{log_bn}$的性质P56。  令a$\\ge$1和b\u0026gt;1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： T(n) = a * T(n/b) + f(n)，其中我们将n/b解释为$\\lfloor n/b\\rfloor$或者$\\lceil n/b\\rceil$。那么T(n)有如下渐进界。\n   对某个常数$\\epsilon\u0026gt;0$，有 f(n) = $O(n^{log_ba−\\epsilon})$, 则 T(n) = $\\theta(n^{log_ba})$。（叶子节点占主导）    f(n) = $\\theta(n^{log_ba})$, 则 T(n) = $\\theta(n^{log_ba}logn)$ 。（根节点叶子结点差不多）    对某个常数$\\epsilon\u0026gt;0$，有 f(n) = $\\Omega(n^{log_ba−\\epsilon})$, 且对某个常数c\u0026lt;1和所有足够大的n有$af(n/b)\\le cf(n)$，则 T(n) = $\\theta(f(n))$。（根节点占主导）    strassen算法 书中有穿插着讲矩阵乘法的strassen算法，以它的复杂度为例。P44有伪代码。一般针对方阵，不是方阵可以补成方阵。\n 为什么要strassen算法？可能是因为原来效率太低了$O(n^3)$，即使做分块运算效率也很低，用加入一些矩阵加法的运算，减少矩阵乘法的运算的方法来提高效率，用strassen做矩阵乘法可以达到$O(n^{log_27})$相当于$O(n^{2.81})$。strassen算法就是运用了分而治之的思想将矩阵分块套公式运算，本质上还是“简化”的矩阵乘法。\n为什么strassen算法的时间复杂度是线性的？P124（1/5+7/10\u0026lt;1）继续迭代下去就是线性的。\n博主用c语言实现了一下strassen算法，按照伪代码的思路没问题，就定义一下矩阵的加法、减法和乘法运算就可以了，在2^11次规模下真的很慢，要运行将近一个小时，比普通乘法还慢（即使用strassen算法，在较小规模的情况下可以还是使用普通乘法）。有同学用c++里的vector来实现，好像速度还挺快，以后可以尝试一下。\n  另外：做课后习题的时候，需要掌握简单的级数展开的知识，可以看一下前几章的内容。 lg(n!)=$\\theta$(nlgn)课后习题会用到。\n有的时候还要用到高中求解数列通项公式的技巧，同除啊换元啊什么的。\n说实话，算法里有很多内容在离散数学中都讲过，感觉又温习了一遍！\nP54页上有提到“非多项式意义上大于”的问题（ T(n)=2T(n/2)+nlogn，nlogn并不在多项式意义上大于n），不能用主方法，但可以用递归树方法求解。具体的话，看书啦。\n 空间复杂度： 在此不加以赘述。\n高级分析技巧【摊还分析】：  Ask：三种摊还分析的方法具体指的是什么？ Ans：聚合分析、核算法、势能法。  聚合分析：  先算出一些操作的总数上限，取平均值。（有很多操作，打包计算）\n 核算法：  对某些操作多分配一些代价，下次可以从信用里面取代价。（有几种操作，操作复杂度差不多，让简单操作多算几个，预支一些复杂操作的信用，简化分析过程）\n 势能法：  定义一个势能函数。\n以书中push、pop、multipop为例，他是以栈中还有多少个元素为势函数。$c_i$和$c_i^{hat}$一个表示真实开销一个表示上界。\n 动态表：\n Ask:动态表有什么用？\nAns:对到底需要分配多少空间，心里没有数，动态表不够用了可以扩张，存的内容变少了也可以缩减表空间。\n  课后习题：第一题，pultipush()不是O(1)，因为不知道push多少个，如果改成multipush_5()的摊还分析，还是O(1)的级别。\nn个操作合起来的代价，和一个操作的代价题目要看清楚。\n 找中转站的思维：分两步解决问题，1-\u0026gt;2,2-\u0026gt;3，则1-\u0026gt;3，例如所有线路都通过人民广场，那么所有站点都相互可达。（所有问题都可以转换为一个问题，那个问题又有某种性质，那么所有问题都具有这种性质）。\n算法分析：概率分析和随机算法 经典例题：  生日问题：用逆向思维。课后例题经典，概率论中也会学习。P73。练习5.4-1 球与箱子 特征序列  【排序算法】：  基于比较的排序算法平均时间复杂度最小为O(nlgn)，基于非比较的排序平均时间复杂度最小为O(n).  基于比较的排序： 1. 插入排序 Insertion sort  给定一个数组，每次把新来的数插入之前已经排好的序列中，从只有一个数的序列直到把所有数都排列进去。例如，洗牌。\n  时间复杂度$O(n^2)$  2. 选择排序  头部已排好序，尾部未排好序，每次从未排好序的里面选最值放到已排好序的序列尾端。\n  时间复杂度$O(n^2)$  3. 冒泡排序  两重循环，两两比较，每次最值沉底或上浮。\n  时间复杂度$O(n^2)$  4. 归并排序 留到分治策略那一部分详细叙述。\n 分解：n-\u0026gt;n/2\n解决：使用归并排序递归地排序两个子序列\n合并：合并两个排好序的子序列\n 5. 快速排序 （重点） 跟基准元比较，分成前后两堆，比基准元小的和比基准元大的。\n老师在答疑课上问到我了，我应该这辈子都不会忘了。 我被问到的问题→存不存在一种算法的平均情况下的时间复杂度和最坏情况下的时间复杂度不一样？举个例子。 我回答了快速排序。\n 平均情况下的时间复杂度：O($nlgn$) 最坏情况下的时间复杂度：O($n^2$)。如何达到？ 基准元选的不好，每次都是最大值或者是最小值，每次两边分布一边很多一边很少。每次从小到大或者是从大到小排的数组，效果比较差。每次首尾和基准元比大小，不对就交换 随机选取基准元的快速排序。随机选取基准元平均情况O($nlgn$)，最差情况也是O($n^2$)。   为了防止有人蓄意构造一个序列，使得快速排序变成最坏情况，我们可以随机选取基准元，**random_select()**算法。\n 6. 堆排序 建堆的复杂度：O(n)\n堆一般用数组存储\n 大顶堆：根节点的值比叶子节点的值大\n注意几个函数即可，建堆的时候从1/2处（第一个有孩子的结点）往上调整，和孩子比较，max-heapify()\n堆排序就是构造完大顶堆之后，extract-max()和数组最后一个交换，heapsize- -，然后再对根max-heapify()，以此类推。\n 基于非比较的排序： Ask：为什么非比较排序的复杂度可以到达O(n)是不是很神奇？有什么需要满足的条件吗？ - 排序算法为什么可以到O(n)，这不是很奇怪吗？\nAns:非比较排序的【前提】：输入数据的种类总是有限的、有一定范围的，列举一下算法的例子，例如人的身高统计，统计到厘米的精度，还是0.0000001的精度，范围很大就不一定行了。基于非比较的排序实际上是把问题范围从大问题缩小到小问题，用空间换时间。\nAsk：基于比较的排序算法有一棵树，长什么样子？P107\nAns:路径的长度就是比较的次数，每个叶子节点就是输入的排序。排列组合，三个数有多少种排列，3！。多少种排序情况，就有多少个叶子结点，要经过多少次查找才能找到。\n7.计数排序  有一定条件，元素个数和种类是指定的。基于统计的排序。\n确定数字种类，分别统计数量，在新的数组的相应位置插入这个数字。\n 8.基数排序  把数分为几个部分，分别排序。例如一个三位数，先排个位再排十位，最后排百位。\n分成几个位数，有限个。先排最低位。在d和k参数。。\n 9.桶排序  P119找最小值，找最大值，要找n次。同时找最小值和最大值，实际上只用找1.5n次。方法：取两个数，其中大的之和最大值比，小的之和最小值比。\n 【中位数和顺序统计量】： 如何求中位数：\n方法一：先排序，排序。\n方法二：select算法\nRANDOMIZED-SELECT  O(n)的复杂度。\n用了快速排序的partition方法，分两段。\n可以用于找中位数，但是扩展来说找1/4，1/3位置的数都可以。找分位数的可以用于设计等高的直方图，更方便描述数据集合的轮廓。设计等高直方图，找n次SELECT可以达到O(n),也可以直接排序有O(nlogn)的复杂度，所以O(min(nlogn,n))。有多种方法哦！不要思维定势。\n SELECT()算法，期望为线性时间  五个五个分组，每组排好序，找中位数，去掉四分之三不用比较的，再继续。\n复杂度是O(n)\n 最坏时间为线性时间，暂时不考试。\n【查找算法】 顺序查找 一般基于数组，无序的数组就可。O(n)\n二分查找 一般基于数组，但是要有序的数组。\n 插入删除查询的复杂度来分析两个算法。插入：顺序查找要O(1)插在最后一位，二分查找是有序的，平均O(n)的开销。如果删了不移动，分别是O(n)和O(logn)，如果删了要移动，则都是O(n)。查找代价分别是O(n)和O(logn)。\n **二叉搜索树的性能来对比，二叉搜索树不是重点，不能保证任何一个复杂度，我们寻求的终点是二叉平衡树！！！**插入、删除、修改全部可以变成O(logn)。二叉搜索树可以达到O(logn)这个是不对的。\n哈希查找 直接寻址法；除留余数法；开放寻址法（线性探测，二次探查，双双重散列），再哈希法\n【分治策略】 分治算法怎么理解？\n举几个例子：归并排序，快速排序，strassen算法的矩阵乘法。\nstrassen算法O($n^{log7}$)=O($n^{2.81}$)很有名\n【动态规划】 和分治算法的区别就是子问题可以复用。例如，分治算法的矩阵乘法，分块计算就不相关。\n经典问题： 钢条切割问题 假设0-9米的钢条情况都已经知道了，到10划分最优子结构也知道了。\n矩阵链的乘法 完全背包问题（贪心算法不能达到最优）：  价值、体积、背包大小。子体积的最优解全部记录下来。\n 最长公共子序列  用一个二维的矩阵记录，一行一行来，然后有一个表达式，就是(i,j)的值和(i-1,j)和(i,j-1)相关，如果这一位刚好相等，在两者较大的哪个基础上加1即可，不相同取其中较大的那个即可。在写算法的时候一路走，一路会记录方向，方便往回找。\n 【贪心算法】 每次都做了局部最优得选择，但不一定是全局最优的。\n经典问题： 活动选择问题/会议调度安排问题： 选择最早开始或者最不冲突的是无法达到全局最优的，但是用最早结束的是可以达到最优的。\n0-1背包问题和分数背包问题  老师提问→什么问题不能用贪心算法解决？举几个例子。 answer：0-1背包问题，不可用贪心算法解决，要用动态规划的算法解决，但是分数背包问题可以用贪心算法解决。*分数背包问题如何解决？*每次都取性价比最高的装满书包。  赫夫曼编码 为了使文本变短。对频率进行排列。\n有一个性质就是头部不冲突，怎么解释？\n前缀码长得不一样，使得编码是唯一的，能识别的。\n【堆】 堆排序（之前提到过） 堆的话一般是数组，堆可以转变成一棵树P84。大顶堆（父结点的值比子结点）、小顶堆。\n建堆的复杂度O(n)，$theta(n)$。从第一个有子节点的往上走。\n堆排序的开销是O(nlogn)。堆排序的开销不可能是O(logn)。\n堆的好处是可以用来做优先级队列。\n优先队列 一般用堆来实现。\n按照key的大小，每次选第一大的。\n斐波那契堆 除了删除和取最值操作和二叉堆的代价一样，其他操作的均摊代价可以达到O(1)，非常理想。P290\n【树】  Ask:树和图的最大区别是什么？ Ans：树没有环。  二叉搜索树 用堆构成的二叉树，不是二叉搜索树。二叉树是左边小右边大，堆是父节点最小。\n二叉树不一定是平衡树，平衡树才是目的！！\n利用二叉搜索树中序遍历输出就是已经排好序的结果。\n插入：比较比它则往左边走，比它大则往右边走，直到找到合适的位置。\n查找：比较比它则往左边走，比它大则往右边走，直到查找。\n删除：有三种案例。\n红黑树 Ask:为什么红黑树是一个平衡树？\nAns：在红黑树里根节点到叶节点的路径，最长的不会超过最短的两倍，可以看作同一个量级。为什么可以满足这个性质呢？红节点底下只能是黑结点。\n什么是黑高？\n 从该结点到叶子结点的简单路径，包含相同数目的黑色结点\n 例如，一颗空的树，插入一个1，那黑高等于几？黑高等于1。因为根节点必须是黑色的（但算黑高的时候，本身不算），Nil结点也是黑色的。\n每次插入新的结点都是红色的。\n满足几个条件：   1.每个结点要么红，要么黑\n  2.根节点为黑色\n  3.叶子结点都为黑色\n  4.每个红色结点下只能接黑色结点\n  5.每个点的黑高都相等\n最后可以达到相对平衡的程度，最长边最多是最短边的两倍，不会再长了。\n  红黑树的旋转： 为了维护黑高的性质。\n红黑树结点插入的过程，伴随旋转变色的三种情况（若插入红节点，父亲结点也为红）：\n1.叔结点是红色。父结点变红色，本身和叔结点变黑色。\n2.叔结点是黑色，插入的结点是左孩子，制作左旋转，变case3。\n3.叔结点时黑色，插入的结点是右孩子，旋转+变色。\nAVL树 AVL树可以达到的效果：最短边和最长边的差距不超过1 具体的实现再说吧，了解一下好了\nHuffman 树 (贪心算法中也会提到)  Ask:Huffman编码是什么？如何实现？ Ans:以往都是用定长码标记，用Huffman 树可以生成变长的前缀码，使得短的编码不是任何长的编码的前缀（代表的key都在叶子节点上，无前缀），又使得出现频率较高的编码长度较短，达到压缩的目的。用贪心算法的思想实现，每次找权重最小的两个结点，合成一个新的权重，再不断地重复上述操作，最后生成一棵树。  【散列表/哈希表】 直接寻址法，给你一个位置，在这个位置上自己扩展。拉链法。\n开放寻址法，冲突了之后。线性探查：依次线性往后找；二次探查：后续探查的时候要加一个偏移量，有一个平方；双重散列：有两个散列函数线性组合去查找。反正给了这么多空间，满了就去占别人的空间。\n发生哈希碰撞时的处理方法（老师提问）：  answer：（1）拉链法（链式存储方法）新开一个链表存储（2）开放定址法：在原数组上存储。开放定址法又有一些具体的方法。  【动态表】 整块扩大和缩小 分析复杂度\n【图】 图的表示： 邻接矩阵：稠密的话可以用它。\n邻接链表：稀疏的话可以用它。\n广度优先搜索BFS 广度优先遍历，先找到他所有的子节点，再遍历子节点下一层。\n 队列\n 深度优先搜索DFS 深度优先遍历，先找到最深的再不断遍历过来。\nAsk：旅行商问题里的近似问题的算法，用的是BFS还是DFS？\nAns：旅行商问题，找欧拉回路，找最小生成树，然后双向，再优化替换点，典型的深度遍历。\n 栈\n 最小生成树 Ask:最小生成树的定义？\nAns：树是没有回路的，和图不同。再图中找到一棵树，总权重最低。\n最小生成树有什么用？answer：举个例子，使得所有的结点之间连接成本最低。\n Ask:这两个算法的本质是什么？有什么原则？ Ans：本质在于有两个不同的集合，一个是已经选取的边的集合S，一个是未经选取的边的集合E-S，每次选取的边都是连接这两个集合的最短边，它必在最小生成树里，只是选取的策略不同罢了。  Kruskal  每次选取最小的边（只要不是同根，不会形成一条回路）。 最坏情况下：O(mlogm)  Prim  从一个结点往外扩展，每次选取S和V-S之间的最短边。 最坏情况下：O($n^2$)  单源最短路径（不能包含负权回路） 首先定义了两个函数：(v.d代表到源点的距离，v.p代表连到该点的上一个点)P377\n初始化函数：每个点的v.d=无穷和v.p=nil\n松弛函数：如果v.d\u0026gt;u.d+w(u,v)，那么v.d=u.d+w(u,v)，v.p=u。\n 感觉松弛操作更像拧紧螺丝，把线卷起来。\n Bellman-Ford（权值可以为负数）*不考  看书上P379的伪代码就懂了。首先，初始化。而后，对所有边进行松弛操作，这样做V-1次（对所有边的松弛操作）。最后，再对所有边用松弛条件去判断还会不会有变化，有变化则有负环，返回false，无变化则返回true。 可能这样看会觉得挺有道理的，老师课上说的总结才是真的精辟。   此处，长度代表有几条边。\n最短路径长度\u0026lt;=k-1\n1  第一次可以找到长度为1的最短路径   1  第二次可以找到长度为2的最短路径   1  ......   1  k-1轮可以算出长度为k-1的最短路径（最长的最短路径最大为k-1）   所以这样一来应该可以算出单源最短路径了。\n再进行一轮松弛，如果有变化的话，肯定就是有负环，找不到单元最短路径的情况啦！\n算法复杂度O(VE)。也很显然有很多不必要的操作嘛，就感觉像是穷举。\n    参考：blog:https://www.cnblogs.com/Jason-Damon/archive/2012/04/21/2460850.html\n Dijkstra（权值不能为负数） 本质是从一个点不断扩展的过程\n Dijkstra就像摊大饼，每次都把最小的纳入（贪心策略），然后做松弛操作。 算法复杂度依赖于优先队列的实现。P386普通线性搜索，总体复杂度O($V^2$)，用二叉堆，O(ElgV)，用斐波那契堆，可以改善到O(VlgV+E)。 最坏情况下：O($n^2$)  所有结点对的最短路径 Floyd-Warshall 最大流和最小切(割) Ask:什么是最大流？\nAns:两个点之间的流量最大，关心能不能运到，不关心运输时间。用FF算法，用增补网络。\n几个概念P419的图  残存网络：有残存容量（有流量不论正反，能够为容量增加的最大值）的边组成的网络 增广路径 ：简单来说就是从源结点s到汇点t的一条/几条可以流通的边 切割：把点集分为两部分S和T；净流量（f(S,T)）算s-\u0026gt;t减去t-\u0026gt;s,容量（c(S,T)）只算s-\u0026gt;t的。 每条边上都有最大的限流，边上标注的是流量而不是距离。 最大流：从源结点s到汇点t，所有的可行路加起来，最多可以送多少。 P425图 贪心的找到一条直接去除是不行的。P425有翻转可以循环利用的。可能把非常霸道的一条边去掉了，断了多条边的路。课上有举例子。 P423 最大流最小切割定理 三个等价条件  Ford-Fulkerson算法  初始化增广网络。只要有一条路，就找路段中最小的当作这条路的流量。（在图中可以反向表示，即补偿表示，表示成残存网络的形式）直到没有路可以走，总流量也就求出来了。 O(E|f*|)\n Edmonds-Karp算法 用广度优先搜索算法改进Ford-Fulkerson算法。 O(V$E^2$)\nP417 26.1-1 最大流G\u0026gt;=G',和G\u0026lt;=G‘来证明最大流的值相等。假设G\u0026rsquo;中存在包含该路径的最大流，那么把该路径替换，这条路也出现在G中，G的最大流肯定大于等于它。。。\n多个s，再模拟一个总体的s。P417\n广度优先用队列来做，一层一层的，先把儿子都找完再找孙子。\n摊大饼：估计长度+真实长度。\n【P和NP】P616 P和NP  p表示多项式，是Polynomial的缩写。多项式时间内可解。 NP表示在多项式时间内可以验证结果。np问题是验证性问题，如果在多项式时间内可验证，则就是np问题。 np完全问题 多项式可归约，怎么表示  什么是团问题？团是一个完全图，任意两点之间有连线。\n什么是顶点覆盖问题？找一个点的集合，这个点的集合是最少的，对于图中的边，至少有一个顶点在里面。对于一个只有点没有边的图，顶点覆盖问题返回什么？返回空集。图里有很多点，任意两点都有边，顶点覆盖返回什么？返回N-1（N-2就不行啦）\n什么是哈密尔顿回路问题？在一个大图中，是否存在所有点的简单回路。\nNP是不是P不知道，只知道NP问题难度差不多。怎么解决，我们想到一些近似算法。\nNP **若一个算法能够在多项式时间之内被验证对错，这个算法被称为NP算法。**NP问题是判定问题。\n例如旅行商问题：给出一条线路，要验证是不是一条小于k的线路。验证的时候只要加和看是否小于k即可。所以旅行商问题是NP问题。\n排序不是一个NP问题，排序是个动作不是一个决定/问题，问一个序列是否有序，这是个NP问题，可以在多项式时间内被验证。\n所有的p问题都是np问题（在多项式时间内可解、在多项式时间内可验证），但是np问题是否为p问题，尚未被验证。\nnp问题有很多很多。np-complete是np问题中的一类，像TSP这种可以归约到一类的问题，目前大概有一万多种（？），都是np-complete。np-complete目前还没有被证明是不是多项式级的问题，但是可以用多项式规约为一类问题。\nnp-hard是对难度的衡量。\n几个NP问题 TSP问题 旅行商问题 高复杂度问题  假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。 目前最好的算法O($n2^n$)  clique问题，clique完全图(团，每个点和其他边都相邻)，对于一个图找出里面的最大团等于几  是否在图中存在团C，使得|C|\u0026gt;K。其实就是找图中最大的完全图。 O(n$2^n$)  对于NP问题不知道它究竟是不是P问题（究竟是不是多项式时间内可解）现在还是不确定的。\nSAT问题（satisfiability problem）布尔表达式的可满足性问题 与或非表达式。看输入一串$x_i\u0026hellip;\u0026hellip;x_n$用与或非把他们连接起来。是否存在一串$x_i\u0026hellip;\u0026hellip;x_n$的值使得表达式为TRUE，看是否存在表达式为True的情况，看$x_i$分别要取什么值。\n如果是或的关系，不用连线只要一个true就行了；相反的也不连线。最后找到一个团，就有使得整个表达式为True的值。\n代入验证很方便，可以在多项式时间内验证完毕。\n它是NP-complete问题。\n所有问题遍历完之后有O($2^n$)的复杂度。\n近似算法 近似算法，就是给定一个参数$alpha$，返回的解在$alpha$和$2alpha$之间。（？）\n顶点覆盖问题 可以找到一个顶点集合，所有点覆盖在里面。\n如果没有边返回空集，如果是个完全图，返回N-1个结点（N-2个结点就不行了，在两个去掉的点之间连线）。\n怎么解决这个问题？有一个近似算法。每次随机取一个结点，把相关的边都去掉。这样一个集合，比最优的集合，点数不超过它两倍。假设超过最优的集合的两倍了，有一个点就连不上了。（一条边连接两个点）（要涵盖一条边，两个顶点至少一个要在里面。如果都没被选中就不能被覆盖了）\n小于等于最优解的两倍。\n旅行商问题 做一个最小生成树，把两点之间的边double一下形成一条回路，然后它小于等于两倍的欧拉回路。欧拉回路，七桥问题，走一圈经过所有边。P655 再优化一下，经过两次的直接用一条边连接（三角不等式）。\n目前最好的复杂度O($n^22^n$)。\n集合覆盖问题 用最少的人，达到最好的效果，涵盖最多的功能。贪心算法，每次找最全面的人（覆盖范围最大的），把能力范围缩小，再找最全面的人，以此类推。\n归约关系 已知pi问题想知道pi’问题有多难。对于输入x’经过一个函数f，放到算法pi中求解，看输出结果。若f复杂度知道，pi的复杂度又知道，那么总体的复杂度都知道了。其实就是转化。（叫多项式规约是因为f的复杂度是一个多项式）\nP638几个问题的归约的关系。\n SAT\u0026lt;=Clique。SAT可以归约到Clique问题。PPT上有。$x_i$和$非x_i$两个矛盾，无连线。必选，转换成找环的问题。  对于NP问题，我们一般设计近似算法把问题解决掉。\n实验总结 1.merge sort算法和insertion sort和bubble sort\n2.Strassen算法\n3.堆实现优先级队列\n4.计数排序（count sort）\n5.随机选择算法（rand select）、选择算法（SELECT）\n6.红黑树构建\n7.最长公共子序列\n8.动态规划 优化的二叉搜索树\n9.Dynamic table\n10.贪心算法\n11.最小生成树\n12.dijkstra\n13.最大团\n","permalink":"https://Isaray.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","tags":["Algorithm"],"title":"Algorithm "},{"categories":["Experiments"],"contents":"CSAPP:memory mountain 画memory mountain存储器山： https://blog.csdn.net/weixin_41724000/article/details/100072251 http://csapp.cs.cmu.edu/3e/students.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  /* mountain.c - Generate the memory mountain. */ /* $begin mountainmain */ #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026#34;fcyc2.h\u0026#34; /* measurement routines */#include \u0026#34;clock.h\u0026#34; /* routines to access the cycle counter */ #define MINBYTES (1 \u0026lt;\u0026lt; 14) /* First working set size */#define MAXBYTES (1 \u0026lt;\u0026lt; 27) /* Last working set size */#define MAXSTRIDE 15 /* Stride x8 bytes */#define MAXELEMS MAXBYTES/sizeof(long)  /* $begin mountainfuns */ long data[MAXELEMS]; /* The global array we\u0026#39;ll be traversing */ /* $end mountainfuns */ /* $end mountainmain */ void init_data(long *data, int n); int test(int elems, int stride); double run(int size, int stride, double Mhz); /* $begin mountainmain */ int main() { int size; /* Working set size (in bytes) */ int stride; /* Stride (in array elements) */ double Mhz; /* Clock frequency */ init_data(data, MAXELEMS); /* Initialize each element in data */ Mhz = mhz(0); /* Estimate the clock frequency */ /* $end mountainmain */ /* Not shown in the text */ printf(\u0026#34;Clock frequency is approx. %.1f MHz\\n\u0026#34;, Mhz); printf(\u0026#34;Memory mountain (MB/sec)\\n\u0026#34;); printf(\u0026#34;\\t\u0026#34;); for (stride = 1; stride \u0026lt;= MAXSTRIDE; stride++) printf(\u0026#34;s%d\\t\u0026#34;, stride); printf(\u0026#34;\\n\u0026#34;); /* $begin mountainmain */ for (size = MAXBYTES; size \u0026gt;= MINBYTES; size \u0026gt;\u0026gt;= 1) { /* $end mountainmain */ /* Not shown in the text */ if (size \u0026gt; (1 \u0026lt;\u0026lt; 20)) printf(\u0026#34;%dm\\t\u0026#34;, size / (1 \u0026lt;\u0026lt; 20)); else printf(\u0026#34;%dk\\t\u0026#34;, size / 1024); /* $begin mountainmain */ for (stride = 1; stride \u0026lt;= MAXSTRIDE; stride++) { printf(\u0026#34;%.0f\\t\u0026#34;, run(size, stride, Mhz)); } printf(\u0026#34;\\n\u0026#34;); } exit(0); } /* $end mountainmain */ /* init_data - initializes the array */ void init_data(long *data, int n) { int i; for (i = 0; i \u0026lt; n; i++) data[i] = i; } /* $begin mountainfuns */ /* test - Iterate over first \u0026#34;elems\u0026#34; elements of array \u0026#34;data\u0026#34; with * stride of \u0026#34;stride\u0026#34;, using 4x4 loop unrolling. */ int test(int elems, int stride) { long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4; long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0; long length = elems; long limit = length - sx4; /* Combine 4 elements at a time */ for (i = 0; i \u0026lt; limit; i += sx4) { acc0 = acc0 + data[i]; acc1 = acc1 + data[i+stride]; acc2 = acc2 + data[i+sx2]; acc3 = acc3 + data[i+sx3]; } /* Finish any remaining elements */ for (; i \u0026lt; length; i++) { acc0 = acc0 + data[i]; } return ((acc0 + acc1) + (acc2 + acc3)); } /* run - Run test(elems, stride) and return read throughput (MB/s). * \u0026#34;size\u0026#34; is in bytes, \u0026#34;stride\u0026#34; is in array elements, and Mhz is * CPU clock frequency in Mhz. */ double run(int size, int stride, double Mhz) { double cycles; int elems = size / sizeof(double); test(elems, stride); /* Warm up the cache */ //line:mem:warmup  cycles = fcyc2(test, elems, stride, 0); /* Call test(elems,stride) */ //line:mem:fcyc  return (size / stride) / (cycles / Mhz); /* Convert cycles to MB/s */ //line:mem:bwcompute } /* $end mountainfuns */   ","permalink":"https://Isaray.github.io/csapp-memory_mountain/","tags":["CSAPP","Courses"],"title":"CSAPP:memory mountain"},{"categories":["Experiments"],"contents":"CSAPP:shlab 该实验对应CSAPP第8章：异常控制流，可以先温习该章内容再做实验。\n通读实验指南，了解实验目的：\n简介 The purpose of this assignment is to become more familiar with the concepts of process control and signalling. You’ll do this by writing a simple Unix shell program that supports job control.\n本实验的目的就是写一个简单的Unix shell，主要任务就是修改tsh.c文件，需修改以下7个函数。\n   1.void eval(char *cmdline); //解释命令[70 lines]\n  2.int builtin_cmd(char **argv);//识别命令是否为内置命令quit、jobs、fg、bg ，若是，则执行对应命令.[25 lines]\n    quit命令会终止shell。 jobs 命令列出所有后台工作。 bg 命令通过发送一个 SIGCONT 信号重新启动，然后在后台运行。参数可以是 PID 或 JID。 fg 命令通过发送一个 SIGCONT 信号重新启动，然后在前台运行。     3.void do_bgfg(char **argv);//执行bg,fg操作[50 lines]\n  4.void waitfg(pid_t pid);//等待前台操作完成 [20 lines]\n  5.void sigchld_handler(int sig);//抓住 SIGCHILD [信号80 lines]\n  6.void sigtstp_handler(int sig);//抓住 SIGINT (ctrl-c) 信号[15 lines]\n  7.void sigint_handler(int sig);//抓住 SIGTSTP (ctrl-z) 信号[15 lines]\n   关于你输入的命令： 如果第一个词是内置的命令，shell会在当前进程中立即执行该命令，否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。\n如果命令行以\u0026quot;\u0026amp;\u0026ldquo;结尾，则作业在后台运行，这意味着shell在打印提示符和等待下一行命令前，不会等待job结束。否则，job在前台运行，这意味着shell在等待下一个命令行之前会等待job终止。因此，在任何时间点上，最多只能有一个job在前台运行。但是，可以有任意数量的job在后台运行。\n下面一段说明很好地解释了main中的参数argc、argv代表什么意思（这里环境的参数被省略了）：\n Typing the command line tsh\u0026gt; /bin/ls -l -d runs the ls program in the foreground. By convention, the shell ensures that when the program begins executing its main routine\nint main(int argc, char *argv[])\nthe argc and argv arguments have the following values:\n• argc == 3,\n• argv[0] == ‘‘/bin/ls’’,\n• argv[1]== ‘‘-l’’,\n• argv[2]== ‘‘-d’’.\nargc指的是参数个数，argv是指针数组，每个指针指向一个参数字符串。\n 一些注意事项：\n 如果命令行以＆结束，则tsh应该在后台运行job。 否则，它将在前台运行该job。 每个作业都可以由进程ID（PID）或作业ID（JID）标识，该ID是tsh分配的正整数。 JID应该在命令行上以前缀“％”表示。 例如，“％5”表示JID 5，“ 5”表示PID5。 tsh应该管理回收（reap）所有的僵尸子进程。 如果任何job由于接收到未捕获到的信号而终止，则tsh应该识别此事件并打印一条带有该job的PID的消息以及对该问题的信号的描述。 job Id 和 process id 是有区别的，前者需要以%为前缀，后者为一个数字。这一点在处理bg、fg指令时尤为重要 在eval中一定要   在fork子进程前用sigprocmask阻塞SIGCHLD信号；fork之后解除该阻塞 在加子进程到joblist前调用sigprocmask阻塞全部信号 因为子进程会从父进程处继承阻塞信息，所以在execve其他二进制文件前，一定要解除信号阻塞 子进程按照建议应该在 sigchld_handler被收割（reap），所以父进程需要在调用addjob之前阻塞SIGCHLD信号，以防止竞态条件   当在标准unix shell中运行tsh程序时，从tsh程序fork出来的子程序会和tsh处于同一个process group；因此你需要使用setpgid来重置子进程process group id；如若不然，在ctrl-c \u0026amp; ctrl-z的处理上会有一些问题 用sigprocmask阻塞信号，因为有时候不希望在接到信号时就立即停止当前执行，去处理信号，同时也不希望忽略该信号，而是延时一段时间去调用信号处理函数。  检验结果用到的一些命令 先make\n共16组测试数据，test结果要和rtest完全一样才算通过。\nmake test01 相当于 ./sdriver.pl -t trace01.txt -s ./tsh -a \u0026quot;-p\u0026quot;\nmake rtest01 相当于 ./sdriver.pl -t trace01.txt -s ./tshref -a \u0026quot;-p\u0026quot;\n实验代码和注释 eval eval解析输入的命令： 如果第一个词是内置的命令builtin_cmd(argv)，shell会在当前进程中立即执行该命令。 否则，假定该词是可执行程序的路径名，在这种情况下，shell会fork一个子进程，然后在子进程的上下文中加载并运行程序。\n 注意：在创建子进程前要阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，导致信号丢失，所以在fork子进程前阻塞sigchld信号，并在fork,addjob后解除\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  /* * eval - Evaluate the command line that the user has just typed in * * If the user has requested a built-in command (quit, jobs, bg or fg) * then execute it immediately. Otherwise, fork a child process and * run the job in the context of the child. If the job is running in * the foreground, wait for it to terminate and then return. Note: * each child process must have a unique process group ID so that our * background children don\u0026#39;t receive SIGINT (SIGTSTP) from the kernel * when we type ctrl-c (ctrl-z) at the keyboard. */ void eval(char *cmdline) {\t// static char array[MAXLINE]; /* holds local copy of command line */ // char *buf = array; /* ptr that traverses command line */ char *argv[MAXARGS];\t//命令行参数 pid_t pid;\t//子进程PID int bg; // 最后是否是\u0026amp;，即是否后台执行， sigset_t mask_one, prev, mask_all; // strcpy(buf, cmdline);\t//缓存命令行 bg = parseline(cmdline, argv); if(argv[0] == NULL) return;//忽略空行 if(!builtin_cmd(argv)){//如果不是shell的内嵌命令 sigemptyset(\u0026amp;mask_one);//初始化信号量集 sigaddset(\u0026amp;mask_one, SIGCHLD);//将SIGCHLD添加到信号量集中 sigfillset(\u0026amp;mask_all);// 设置全阻塞 sigprocmask(SIG_BLOCK, \u0026amp;mask_one, \u0026amp;prev);//阻塞信号 ，为了避免父进程运行到addjob之前子进程就退出了，所以在fork子进程前阻塞sigchld信号，addjob后解除 if((pid = fork()) == 0){\t// 子进程继承了父进程的阻塞向量，也要解除阻塞，避免收不到它本身的子进程的信号 setpgid(0, 0);\t//把pid=0放到gpid=0的进程组 sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL);//恢复被屏蔽的信号，防止遗漏 //容错 if(execve(argv[0], argv, environ) \u0026lt; 0){ printf(\u0026#34;%s: Command not found\\n\u0026#34;, argv[0]); exit(0); } } sigprocmask(SIG_BLOCK, \u0026amp;mask_all, NULL); addjob(jobs, pid, bg?BG:FG, cmdline); sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL);\tif(bg){ //在后台解除屏蔽\tprintf(\u0026#34;[%d] (%d) %s\u0026#34;, pid2jid(pid), pid, cmdline); }else{\twaitfg(pid); } } return; }   builtin_cmd 判断是否内置命令（1是，0否），并执行对应操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /* * builtin_cmd - If the user has typed a built-in command then execute * it immediately. */ int builtin_cmd(char **argv) { if(!strcmp(argv[0], \u0026#34;quit\u0026#34;)){ exit(0); } if(!strcmp(argv[0], \u0026#34;jobs\u0026#34;)){ listjobs(jobs); return 1; } if(!strcmp(argv[0], \u0026#34;\u0026amp;\u0026#34;)){ // ignore singleton \u0026#39;\u0026amp;\u0026#39; return 1; } if(!strcmp(argv[0], \u0026#34;bg\u0026#34;) || !strcmp(argv[0], \u0026#34;fg\u0026#34;)){ do_bgfg(argv); return 1; } return 0; /* not a builtin command */ }   do_bgfg 在命令行中的第一个参数argv[0]可以用于判断输入的是bg还是fg命令。 PID和JID有不同的格式，分别用不同的方式读入sscanf(argv[1],\u0026quot;%d\u0026rdquo;,\u0026amp;pid)和sscanf(argv[1],\u0026quot;%%%d\u0026quot;,\u0026amp;jid)，若都不是，则会输出错误提示。\n  每个作业都可以由进程ID（PID）或作业ID（JID）标识，该ID是tsh分配的正整数。 JID应该在命令行上以前缀“％”表示。 例如，“％5”表示JID 5，“ 5”表示PID5。   看process或者job是否存在，不存在则报错，若存在则修改状态，并重启。 若是fg前台则等待前一个进程结束，若是bg后台则输出相应字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  /* * do_bgfg - Execute the builtin bg and fg commands */ void do_bgfg(char **argv) {\tint jid; struct job_t *job; pid_t pid; sigset_t mask, prev; //argv[0]判断bg还是fg if(argv[1] == NULL){ printf(\u0026#34;%s command requires PID or %%jobid argument\\n\u0026#34;,argv[0]); return; } //首先确定是pid还是jid，然后将其转化为kill的参数 //读jid if(sscanf(argv[1],\u0026#34;%%%d\u0026#34;,\u0026amp;jid) \u0026gt; 0){\tjob = getjobjid(jobs, jid);\t//需要获得job，因为要修改job信息 if(job == NULL || job-\u0026gt;state == UNDEF){ printf(\u0026#34;%s: No such job\\n\u0026#34;, argv[1]); return; } //读pid }else if(sscanf(argv[1],\u0026#34;%d\u0026#34;,\u0026amp;pid) \u0026gt; 0){\tjob = getjobpid(jobs, pid); if(job == NULL || job-\u0026gt;state == UNDEF){ printf(\u0026#34;(%s): No such process\\n\u0026#34;, argv[1]); return; } }else{ printf(\u0026#34;%s: argument must be a PID or %%jobid\\n\u0026#34;, argv[0]); return; } //修改job信息 sigfillset(\u0026amp;mask); sigprocmask(SIG_BLOCK, \u0026amp;mask, \u0026amp;prev); //更改状态 if(!strcmp(argv[0], \u0026#34;fg\u0026#34;)){\tjob-\u0026gt;state = FG; }else{ job-\u0026gt;state = BG; } sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL); pid = job-\u0026gt;pid; //发送SIGCONT重启 kill(-pid, SIGCONT); if(!strcmp(argv[0], \u0026#34;fg\u0026#34;)){ waitfg(pid);//若是前台则等待前一个进程结束 }else{ printf(\u0026#34;[%d] (%d) %s\u0026#34;, job-\u0026gt;jid, pid, job-\u0026gt;cmdline);//若是后台则输出相应字符串 } return; }   waitfg 等待pid进程不再是前台进程\n1 2 3 4 5 6 7 8 9 10  /* * waitfg - Block until process pid is no longer the foreground process */ void waitfg(pid_t pid) { while(pid == fgpid(jobs)){ sleep(1); } return; }   sigchld_handler //抓住 SIGCHILD 信号 内核在每当子进程终止（成为僵尸）或停止时，因为它收到SIGSTOP或SIGTSTP信号，该处理zombie进程，但不等待任何其他的。终止当前正在运行的子进程。 回收的子进程有三种状态：正常退出、信号退出和信号停止。\n1 2 3 4 5 6 7 8 9 10  if(WIFEXITED(state)){\t// 正常退出 deletejob(jobs, pid); }else if(WIFSIGNALED(state)){\t// 信号退出 printf(\u0026#34;Job [%d] (%d) terminated by signal %d\\n\u0026#34;, pid2jid(pid), pid, WTERMSIG(state));\tdeletejob(jobs, pid); }else if(WIFSTOPPED(state)){\t// 信号停止 job = getjobpid(jobs, pid); job-\u0026gt;state = ST;//注意 printf(\u0026#34;Job [%d] (%d) stopped by signal %d\\n\u0026#34;, job-\u0026gt;jid, pid, WSTOPSIG(state)); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  /***************** * Signal handlers *****************/ /* * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever * a child job terminates (becomes a zombie), or stops because it * received a SIGSTOP or SIGTSTP signal. The handler reaps all * available zombie children, but doesn\u0026#39;t wait for any other * currently running children to terminate. */ void sigchld_handler(int sig) { int old_errno = errno;\tpid_t pid; sigset_t mask, prev; int state;\tstruct job_t *job; sigfillset(\u0026amp;mask);// 设置全阻塞 while((pid = waitpid(-1, \u0026amp;state, WNOHANG | WUNTRACED)) \u0026gt; 0){\t// WNOHANG | WUNTRACED 是立即返回 // 用WIFEXITED(status)，WIFSIGNALED(status)，WIFSTOPPED(status)等来补获终止或者被停止的子进程的退出状态。\tsigprocmask(SIG_BLOCK, \u0026amp;mask, \u0026amp;prev); if(WIFEXITED(state)){\t// 正常退出 deletejob(jobs, pid); }else if(WIFSIGNALED(state)){\t// 信号退出 printf(\u0026#34;Job [%d] (%d) terminated by signal %d\\n\u0026#34;, pid2jid(pid), pid, WTERMSIG(state));\tdeletejob(jobs, pid); }else if(WIFSTOPPED(state)){\t// 停止 job = getjobpid(jobs, pid); job-\u0026gt;state = ST;//注意 printf(\u0026#34;Job [%d] (%d) stopped by signal %d\\n\u0026#34;, job-\u0026gt;jid, pid, WSTOPSIG(state)); } sigprocmask(SIG_SETMASK, \u0026amp;prev, NULL); } errno = old_errno; return; }   sigint_handler 捕捉 SIGINT (ctrl-c) 信号\nsigtstp_handler 捕捉 SIGTSTP (ctrl-z) 信号\n 两个函数写法看起来相似，但是在用sigchld_handler处理的时候有区别，对于 sigtstp_handler我们需要修改job的状态job-\u0026gt;state = ST。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* * sigint_handler - The kernel sends a SIGINT to the shell whenver the * user types ctrl-c at the keyboard. Catch it and send it along * to the foreground job. */ void sigint_handler(int sig) {\tint olderrno=errno; pid_t pid = fgpid(jobs); if(pid!=0){ kill(-pid,sig); } errno = olderrno; return; } /* * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever * the user types ctrl-z at the keyboard. Catch it and suspend the * foreground job by sending it a SIGTSTP. */ void sigtstp_handler(int sig) { int olderrno = errno; pid_t pid = fgpid(jobs); if(pid!=0){ kill(-pid,sig); } errno = olderrno; return; } /********************* * End signal handlers *********************/   参考 README：http://csapp.cs.cmu.edu/3e/README-shlab\n说明：http://csapp.cs.cmu.edu/3e/shlab.pdf\n代码：http://csapp.cs.cmu.edu/3e/shlab-handout.tar\n复习：http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec09.pdf\n博客：\nhttps://zhuanlan.zhihu.com/p/151050267\nhttps://zhuanlan.zhihu.com/p/119034923\nhttps://zhuanlan.zhihu.com/p/89224358\n","permalink":"https://Isaray.github.io/csapp-shlab/","tags":["CSAPP","Courses"],"title":"CSAPP:shlab"},{"categories":["Experiments"],"contents":"CSAPP:malloclab CSAPP:9.9.12 针对空闲块的组织方法有以下三种：\n a.隐式空闲链表(implicit free list) b.显式空闲链表(explicit free list) c.分离空闲链表(segregated free list)  查找空闲块的三个方法：\n a.首次适应(first fit) b.最佳适配(best fit) c.下一次适配(next fit) d.分离适配，特殊情况包括伙伴系统，优点在于快速搜索和快速合并（大小相同，地址连续）。  方案一：隐式空闲链表+first fit/next fit\n 初始化堆 —— mm_init函数 mm_init步骤如下：  首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。\n调extend_heap扩展堆，创建初始的空闲块，大小为4096字节。\n扩展堆 —— extend_heap函数 函数原型: static void *extend_heap(size_t words);  以下两种场景需要扩展堆：\n 调用mm_init初始化堆时。 调用mm_malloc找不到合适的空闲块时。\n 释放和合并块 —— mm_free和coalesce函数   调用mm_free释放块，步骤如下： 将当前块的头部和脚部中的分配位清零。 将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。\n 调用coalesce合并前后的合并块，原型：static void *coalesce(void *bp);，分四种情况：\n 情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。 情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp 情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp) 情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp)\n https://blog.csdn.net/pcj_888/article/details/108812886\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;string.h\u0026gt; #include \u0026#34;mm.h\u0026#34;#include \u0026#34;memlib.h\u0026#34; /********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * provide your team information in the following struct. ********************************************************/ team_t team = { /* Team name */ \u0026#34;ateam\u0026#34;, /* First member\u0026#39;s full name */ \u0026#34;Harry Bovik\u0026#34;, /* First member\u0026#39;s email address */ \u0026#34;bovik@cs.cmu.edu\u0026#34;, /* Second member\u0026#39;s full name (leave blank if none) */ \u0026#34;\u0026#34;, /* Second member\u0026#39;s email address (leave blank if none) */ \u0026#34;\u0026#34; }; static char *heap_listp; #define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1\u0026lt;\u0026lt;12) /* Extend heap by this amount (bytes) */ #define MAX(x, y) ((x) \u0026gt; (y) ? (x) : (y))  /* Pack a size and allocated bit into word */ #define PACK(size, alloc) ((size) | (alloc))  /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) #define PUT(p, val) (*(unsigned int *)(p) = (val))  /* Read the size and allocated fields from address p */ #define GET_SIZE(p) (GET(p) \u0026amp; ~0x7) #define GET_ALLOC(p) (GET(p) \u0026amp; 0x1)// 判断这个块是否已分配  /* Given block ptr bp, compute address of its header and footer */ #define HDRP(bp) ((char *)(bp) - WSIZE) #define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)  /* Given block ptr bp, compute address of next and previous blocks */ #define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) #define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))  /* Globe var */ static char *heap_listp; /* 函数声明 */ static void *extend_heap(size_t words); static void *coalesce(void *bp); static void *find_fit(size_t asize); /* single word (4) or double word (8) alignment */ #define ALIGNMENT 8  /* rounds up to the nearest multiple of ALIGNMENT */ #define ALIGN(size) (((size) + (ALIGNMENT-1)) \u0026amp; ~0x7)  #define SIZE_T_SIZE (ALIGN(sizeof(size_t)))  /* * mm_init - initialize the malloc package. */ int mm_init(void) { if((heap_listp=mem_sbrk(4*WSIZE))==(void*)-1) return -1; PUT(heap_listp,0); PUT(heap_listp+(1*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(2*WSIZE),PACK(DSIZE,1)); PUT(heap_listp+(3*WSIZE),PACK(0,1)); heap_listp+=(2*WSIZE); if(extend_heap(CHUNKSIZE/WSIZE)==NULL) return -1; return 0; } static void *extend_heap(size_t words){ char *bp; size_t size; size=(words%2)? ((words+1) *WSIZE):(words*WSIZE); if((long)(bp=mem_sbrk(size))==-1) return NULL; PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(NEXT_BLKP(bp)),PACK(0,1)); return coalesce(bp); } void place(void *bp,size_t asize){ size_t csize=GET_SIZE(HDRP(bp)); //若剩下的空间比2*DSIZE占的空间大，那么就分割它  if((csize-asize)\u0026gt;=(2*DSIZE)){ PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); bp=NEXT_BLKP(bp); PUT(HDRP(bp),PACK(csize-asize,0)); PUT(FTRP(bp),PACK(csize-asize,0)); } else{ PUT(HDRP(bp),PACK(csize,1)); PUT(FTRP(bp),PACK(csize,1)); } } /* * mm_malloc - Allocate a block by incrementing the brk pointer. * Always allocate a block whose size is a multiple of the alignment. */ void *mm_malloc(size_t size) { size_t asize; size_t extendsize; char *bp; if(size==0) return NULL; if(size\u0026lt;=DSIZE) asize=2*DSIZE; else asize=DSIZE*((size+(DSIZE)+(DSIZE-1))/DSIZE); if((bp=find_fit(asize))!=NULL){ place(bp,asize); return bp; } extendsize=MAX(asize,CHUNKSIZE); if((bp=extend_heap(extendsize/WSIZE))==NULL) return NULL; place(bp,asize); return bp; } void *find_fit(size_t asize) { void *bp; for(bp=heap_listp;GET_SIZE(HDRP(bp))\u0026gt;0;bp=NEXT_BLKP(bp)){ if(!GET_ALLOC(HDRP(bp))\u0026amp;\u0026amp;(asize\u0026lt;=GET_SIZE(HDRP(bp)))){ //寻找第一个可以匹配的块  //heap_listp = bp; //next_fit,每次让它指向最后分配的位置就好，下次从这里匹配  return bp; } } return NULL; } /* * mm_free - Freeing a block does nothing. */ void mm_free(void *bp) { size_t size=GET_SIZE(HDRP(bp)); PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); coalesce(bp); } static void *coalesce(void *bp) { size_t prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size=GET_SIZE(HDRP(bp)); //当两边都被占用 \tif(prev_alloc \u0026amp;\u0026amp; next_alloc){ return bp; } else if(prev_alloc \u0026amp;\u0026amp;!next_alloc){//前一个被占用，后一个空闲，合并后边的 \tsize+=GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); } else if(!prev_alloc\u0026amp;\u0026amp;next_alloc){//后一个被占用，前一个空闲，合并前边的 \tsize+=GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); bp=PREV_BLKP(bp); } else{//两边都空闲，两边都合并 \tsize+=GET_SIZE(HDRP(PREV_BLKP(bp)))+GET_SIZE(FTRP(NEXT_BLKP(bp))); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(size,0)); bp=PREV_BLKP(bp); } return bp; } /* * mm_realloc - Implemented simply in terms of mm_malloc and mm_free */ void *mm_realloc(void *ptr, size_t size) { void *oldptr = ptr; void *newptr; size_t copySize; newptr = mm_malloc(size); if (newptr == NULL) return NULL; copySize = *(size_t *)((char *)oldptr - SIZE_T_SIZE); if (size \u0026lt; copySize) copySize = size; memcpy(newptr, oldptr, copySize); mm_free(oldptr); return newptr; }   ","permalink":"https://Isaray.github.io/csapp-malloclab/","tags":["CSAPP","Courses"],"title":"CSAPP:malloclab"},{"categories":["Experiments"],"contents":"CSAPP:bomblab Bomblab拆弹实录 准备工作 调试环境：  云主机Linux环境+GDB\n ssh客户端：  xshell+xftp/putty+psftp\n xshell+xftp:上传和下载文件有可视化操作界面，直接拖拽就可以上传。但是在gdb调试的时候，输入了的数据不能修改，按回车会输入^H，有的时候会手误就要重新开始。 putty+psftp：上传文件用scp命令（例如：scp hello.c xx@xxx.75.241.219/home/xx/lab0；scp -r 拷贝目录），下载文件可以用psftp。假设要下载到本地目录E:,在psftp中运行lcd E:\\定位本地目录，putty切换到云主机目录之后，get 文件名即可下载。   Linux相关命令 ：   cd document切换到文件夹; cd ..返回上一级目录;ls显示文件夹中的文件;pwd当前目录位置 解压:tar -xf all.tar，tar -zxvf filename.tar.gz cat filename 显示文件内容 vim filename查看/编辑文件内容，i进入编辑模式，esc退出编辑模式，:wq保存并退出，:q没修改直接退出。 复制文件：cp document/file newdocument/newfile 重命名：mv oldname newname   GDB调试：   进入GDB调试状态，gdb filename;或先运行gdb再运行file filename info b看断点情况；b(reak) 行号/函数名 打断点；d (elete) 行号/函数名 删除断点 i r看寄存器的值。info reg esp看%esp里存储了什么。print $eax。print (char*) $ebx。 x/s 0xffff5330 打印该地址存储的字符串；x/16x 地址 答应之后16个字节的数字。 s单步执行（不会进入被调用的函数内部），si单步执行（会进入被调用的函数内部）。c接着运行到下一个断点。 display /ni $pc。用si调试每行都会显示下一行的汇编语言。   题目求解 phase_1:地址字符串  比较字符串是否相等，查看地址中预设的字符串即可。\n phase_2:循环  读入六个数字做判断，读懂汇编语言，知道后一个数等于前两个数的加和即可。\n phase_3:switch \u0026lt;7 每个数对应一个值  是一个switch函数，输入1-7会跳转到不同的地址，和事先存入的数字进行比较。有多个答案。\n phase_4:  递归调用了func4()。首先输入的数字小于等于4。输入4，之后经过递归调用该函数得到216，最后和输入的第一个数字进行比较，所以第一个数字为216，第二个数字为4。应该有不同的答案。\n// int func4(edi ,esi,ebx){//edi last,ebx last %ebx=0x10(%esp) //8 //变成上次的eax，即7 %edi=0x14(%esp) //第二个参数 if ebx== 0 then return 0; eax=edi if ebx==1 then return eax eax=ebx-1. 从头递归。 esi=edi+eax ebx=ebx-2 从头递归。 eax=eax+esi return eax }\n phase_5:  %ebx存放字符串。 x/100x 0x804a040 看这个地址之后存放了什么。理解地址代表的含义是关键。每个输入的字符取十六进制ASCII码的后一位*4+该地址，找到对应的数字，累加到%ecx。最后%ecx要等于41。反推出要输入的字母。\n 0:02;1:a;2:6;3:1;4:c;5:0x10;6:9;7:3;8:4;9:7;10:e;11:5;12:b;13:8;14:f;15:d Prstux 2+6+1+12+16+4=41 phase_6:  读入6个数字，六个数字都\u0026lt;=6，六个数字互不相等。程序里事先存储了6个节点，六个节点有各自的编号，最后要从小到大输出，否则就爆炸。输入的6个数字代表，节点从小到大排列的顺序。\nphase_6太长了，理解了好久，做到最后还挺崩溃的，只能说大胆假设，小心求证。理解地址代表的含义同样是关键，看到node要发挥想象力。\n 5 3 2 1 4 6 0x1d5 0x325 0x391 0x1c6 0x3a5 0xef\nsecret_phase:  secret phase要触发，首先要在phase_4处多输入一个字符串DrEvil。\n首先输入的数字要小于等于1000，然后secret调用func7()，经过func7()之后必须为0。传入一个地址0x804c088，查看它就可以解开题目中预先存储的数据。整个条件判断类似二叉树的结构，要和根节点的值一致且要执行到末端，否则返回-1。又是递归。\n 这只是简要版解题思路，图片后续再补~\n解开一个要缓一缓，然后发现跟后一个phase比起来，前一个简直是小case。发现做到最后最重要的其实是心态。\n最后，有高级语言真好。\n","permalink":"https://Isaray.github.io/csapp-bomblab/","tags":["CSAPP","Courses"],"title":"CSAPP:bomblab"},{"categories":["Experiments"],"contents":"CSAPP:datalab 代码中有具体思路的标注。 以下为实验的说明，每道题目中有规定一些运算符能否使用，使用的符号个数，并规定一些控制结构和函数不能使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  /* * CS:APP Data Lab * * * bits.c - Source file with your solutions to the Lab. * This is the file you will hand in to your instructor. * * WARNING: Do not include the \u0026lt;stdio.h\u0026gt; header; it confuses the dlc * compiler. You can still use printf for debugging without including * \u0026lt;stdio.h\u0026gt;, although you might get a compiler warning. In general, * it\u0026#39;s not good practice to ignore compiler warnings, but in this * case it\u0026#39;s OK. */ #if 0Each \u0026#34;Expr\u0026#34; is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; Some of the problems restrict the set of allowed operators even further. Each \u0026#34;Expr\u0026#34; may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as \u0026amp;\u0026amp;, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting an integer by more than the word size. EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 \u0026lt;\u0026lt; x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 \u0026lt;\u0026lt; x); result += 4; return result; } FLOATING POINT CODING RULES For the problems that require you to implent floating-point operations, the coding rules are less strict. You are allowed to use looping and conditional control. You are allowed to use both ints and unsigneds. You can use arbitrary integer and unsigned constants. You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants. NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operators (! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt;) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that \u0026#39;=\u0026#39; is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source.   以下为所需要写的函数，每个函数的说明和限制都在注释中有具体讲解。\n1.bitAnd ：  不用\u0026amp;，而用|表示\u0026amp;。两者像照镜子，\u0026amp;是同1则1，|是同0则0，用德摩根律，一反再反刚好对称过来。\n 1 2 3 4 5 6 7 8 9 10 11  /* * bitAnd - x\u0026amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */ int bitAnd(int x, int y) { /*It\u0026#39;s equal to find the position that both are 0 and find its reversed version.有点像德摩根律。*/ return ~(~x|~y); }   2.getByte:  先算数左移再算数右移，再减去算数右移增加的补位数\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 6 * Rating: 2 */ int getByte(int x, int n) { /*先算数左移再算数右移，再减去算数右移增加的补位数*/ int t,t1,t2; t1=x\u0026lt;\u0026lt;((3-n)*2*4); t2=t1\u0026gt;\u0026gt;7*4\u0026gt;\u0026gt;4\u0026lt;\u0026lt;(2*4); t=(t1\u0026gt;\u0026gt;(6*4))-t2; return t; }   3.logicalShift:  找出最高位的符号，然后把算数右移前面补的位数减掉即可 ~n+1相当于-n 0xffffffff相当于-1\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 \u0026lt;= n \u0026lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 20 * Rating: 3 */ int logicalShift(int x, int n) { /*找出最高位的符号，然后把算数右移前面补的位数减掉即可*/ int t; t=x\u0026gt;\u0026gt;31\u0026lt;\u0026lt;(32+(~n+1)+0xffffffff)\u0026lt;\u0026lt;1; t=(x\u0026gt;\u0026gt;n)\u0026amp;(~t); //这里用了一个mask小技巧，\u0026amp;mask为1的位置就会显露出来  return t; }   4.bitCount:  原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /* * bitCount - returns count of number of 1\u0026#39;s in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 40 * Rating: 4 */ int bitCount(int x) { /*difficult*/ /*原理：通过同时批量的运算，把操作次数降下来。先理解只有两位的情况，像是将数字两两划分到一个格子里，01比较好理解，就是降次加和，操作完之后每个盒子里都是二进制表示的“1”的个数。再用0011降次加和，把两个盒子合并成一个盒子，以此类推。计数很巧妙！两位比较好想，但是从两位到四位，即把两个盒子合并到一个大盒子，这个方法也很妙！！*/ int mask1=0x55555555;//01(循环至32位)01010101  int mask2=0x33333333;//0011(循环至32位)  int mask3=0x0f0f0f0f;//00001111(循环至32位)  int mask4=0x00ff00ff;//0000000011111111(循环至32位)  int mask5=0x0000ffff;//00000000000000001111111111111111  int t; t=(x\u0026amp;mask1)+((x\u0026gt;\u0026gt;1)\u0026amp;mask1); t=(t\u0026amp;mask2)+((t\u0026gt;\u0026gt;2)\u0026amp;mask2); t=(t\u0026amp;mask3)+((t\u0026gt;\u0026gt;4)\u0026amp;mask3); t=(t\u0026amp;mask4)+((t\u0026gt;\u0026gt;8)\u0026amp;mask4); t=(t\u0026amp;mask5)+((t\u0026gt;\u0026gt;16)\u0026amp;mask5); return t; }   5.bang:  利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。\n 1 2 3 4 5 6 7 8 9 10 11  /* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ int bang(int x) { /*利用0的特性：相反数等于自身。其他的数，相反数和它本身之间肯定有一个负数。*/ return ((x|(~x+1))\u0026gt;\u0026gt;31)+1 ; }   6.tmin:  很简单。根据定义即可。\n 1 2 3 4 5 6 7 8 9  /* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1\u0026lt;\u0026lt;31; }   7.fitsBits:  就是用两种不同方式去解读，判断能不能表示成n位有符号数。 第n位和第n位之前的位数的数字应该都相同，否则就无法表示。判断是否相同用按位与的方式。\n 1 2 3 4 5 6 7 8 9 10 11 12 13  /* * fitsBits - return 1 if x can be represented as an * n-bit, two\u0026#39;s complement integer. * 1 \u0026lt;= n \u0026lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int fitsBits(int x, int n) { /*第n位和第n位之前的位数的数字应该都相同，否则就无法表示。*/ return !((x\u0026lt;\u0026lt;(32-n)\u0026gt;\u0026gt;(32-n))^x); }   8.divpwr2:  非整除情况，如果是负数的话，x\u0026raquo;n结果要加一(n非0)。对于对于负数~(x\u0026raquo;31)=0。整除情况如常。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* * divpwr2 - Compute x/(2^n), for 0 \u0026lt;= n \u0026lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int divpwr2(int x, int n) { /*非整除情况，如果是负数的话，x\u0026gt;\u0026gt;n结果要加一(n非0)。对于对于负数~(x\u0026gt;\u0026gt;31)=0。整除情况如常。*/ int s=!!(x\u0026gt;\u0026gt;31); int t=!!((x\u0026lt;\u0026lt;(32+~n+1))^0); return (x\u0026gt;\u0026gt;n)+(s\u0026amp;t\u0026amp;!!n); }   9.negate:  因为 ~x+x=0xffffffff且0xffffffff=-1。所以-x= ~x+1。\n 1 2 3 4 5 6 7 8 9 10  /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; }   10.isPositive:  x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。\n 1 2 3 4 5 6 7 8 9 10 11  /* * isPositive - return 1 if x \u0026gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 8 * Rating: 3 */ int isPositive(int x) { /*x-1算数右移31位，如果x=0则所有位都为0，否则所有位都为1。*/ return !(x\u0026gt;\u0026gt;31)\u0026amp;!!x; }   11.isLessOrEqual:  即y-x\u0026gt;=0或y\u0026gt;0,x\u0026lt;0(若溢出)。分类讨论。（y\u0026gt;0,x\u0026gt;0,y-x\u0026gt;0）|（y\u0026gt;0,x\u0026lt;0）|（y\u0026lt;0,x\u0026lt;0,y-x\u0026gt;0）\n 1 2 3 4 5 6 7 8 9 10 11  /* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { /*即y-x\u0026gt;=0或y\u0026gt;0,x\u0026lt;0(若溢出)。分类讨论。*/ return (!(y\u0026gt;\u0026gt;31)\u0026amp;!(x\u0026gt;\u0026gt;31)\u0026amp;!((y+~x+1)\u0026gt;\u0026gt;31))|((!(y\u0026gt;\u0026gt;31))\u0026amp;(x\u0026gt;\u0026gt;31))|((y\u0026gt;\u0026gt;31)\u0026amp;(x\u0026gt;\u0026gt;31)\u0026amp;!((y+~x+1)\u0026gt;\u0026gt;31)); }   12.ilog2:  找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* * ilog2 - return floor(log base 2 of x), where x \u0026gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ int ilog2(int x) { /*找到x的最高的非0位。二分法处理，两部分有无1，用0、1表示；位置用1位移累加。很妙！！*/ int t; t=(!!(x\u0026gt;\u0026gt;16))\u0026lt;\u0026lt;4; t=t+((!!(x\u0026gt;\u0026gt;(8+t)))\u0026lt;\u0026lt;3); t=t+((!!(x\u0026gt;\u0026gt;(4+t)))\u0026lt;\u0026lt;2); t=t+((!!(x\u0026gt;\u0026gt;(2+t)))\u0026lt;\u0026lt;1); t=t+(!!(x\u0026gt;\u0026gt;(1+t))); return t; }   13.float_neg:  判断是否为NaN，然后最高位取反。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 10 * Rating: 2 */ unsigned float_neg(unsigned uf) { /*判断是否为NaN，然后最高位取反。*/ unsigned exp=(uf\u0026amp;0x7ff80000)\u0026gt;\u0026gt;23;//011111111100000000000000000000000  unsigned frac=uf\u0026amp;0x7fffff;//00000000011111111111111111111111  if(!(exp^0xff) \u0026amp;\u0026amp; !!(frac^0) )//exp=0xff且frac!=0 \treturn uf;//为NaN返回NaN  return uf^0x80000000;//s位变号即可  }   14.float_i2f:  主要看次数+要不要进位 32-i-1+127即exp flag是看要不要进位\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned i=0,t; unsigned s=(!!(x\u0026gt;\u0026gt;31))\u0026lt;\u0026lt;31; if(!(x^0)) return 0;//为0则0  if(!(x^0x80000000)) return 0xcf000000;//-2^31  if(s) x=~x+1;//负数转换成正数  while(!((x\u0026lt;\u0026lt;i)\u0026amp;0x80000000)){//高位不为1就循环  i=i+1; } t=(x\u0026lt;\u0026lt;i)-0x80000000; int flag=0;//若进位，flag变成1  if((t\u0026amp;0xff)\u0026gt;0x80) flag=1; else{ if((t\u0026amp;0x180)==0x180) flag=1; } t=t\u0026gt;\u0026gt;8; t=s+((32-i-1+127)\u0026lt;\u0026lt;23)+t+flag;//32-i-1+127即exp  return t; }   15.float_twice:  denormalized 的浮点数,exp全为0，乘以2只需将frac左移一位并保持符号不变 normalized 的浮点数，乘以2只需exp++\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { unsigned exp=(uf\u0026amp;0x7ff80000)\u0026gt;\u0026gt;23;//011111111100000000000000000000000  unsigned frac=uf\u0026amp;0x7fffff;//00000000011111111111111111111111  unsigned t; if(!(exp^0xff) ){ return uf;//NaN  } int k=!!(uf\u0026amp;0x7fffffff)\u0026amp;!!exp; t=(uf\u0026amp;0x80000000)+((exp+k)\u0026lt;\u0026lt;23)+(frac\u0026lt;\u0026lt;!exp);//s+exp+frac//exp全0的，frac\u0026lt;\u0026lt;1,exp不变;否则exp++  return t; }   结果： ./btest\n","permalink":"https://Isaray.github.io/csapp-datalab/","tags":["CSAPP","Courses"],"title":"CSAPP:datalab"},{"categories":null,"contents":"CJ Lei\nA student major in data science and engineering.\nLet\u0026rsquo;s listen to some music!\n ","permalink":"https://Isaray.github.io/about/","tags":null,"title":"About Me"},{"categories":null,"contents":"","permalink":"https://Isaray.github.io/search/","tags":null,"title":"Search"}]