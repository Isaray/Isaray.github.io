<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Isaray&#39;s blog</title>
        <link>https://Isaray.github.io/posts/</link>
        <description>All Posts | Isaray&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 27 Jan 2022 16:36:34 &#43;0800</lastBuildDate><atom:link href="https://Isaray.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Zotero的使用</title>
    <link>https://Isaray.github.io/zotero/</link>
    <pubDate>Thu, 27 Jan 2022 16:36:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/zotero/</guid>
    <description><![CDATA[Zotero的安装和使用]]></description>
</item><item>
    <title>How to build our own websites with Hugo on Windows?</title>
    <link>https://Isaray.github.io/build_websites_with_hugo/</link>
    <pubDate>Mon, 17 Jan 2022 16:36:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/build_websites_with_hugo/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/build_websites_with_hugo/featured-image.jpg" referrerpolicy="no-referrer">
            </div>Install Hugo on Wins and build your own website!]]></description>
</item><item>
    <title>Raft</title>
    <link>https://Isaray.github.io/raft/</link>
    <pubDate>Mon, 17 Jan 2022 16:36:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/raft/</guid>
    <description><![CDATA[MIT 6.824 lab2 Raft算法中服务器有三种角色
 Follower Candidate Leader  每个服务器上都会存储的持久状态:
 currentTerm: 当前节点所能看到的最大的term值, 初始化为0并单调递增 votedFor: 当前term里将票投给对象的candidateId, 如果尚未投票则为空(我实现时置为-1) log[]: 日志条目(每条日志条目包含命令和任期), 会按顺序作用于状态机, 第一个索引Index为1  每个服务器上都会存储的易失状态:
 commitIndex: 当前服务器最高的被提交的日志的索引, 初始化为0并单调递增 lastApplied: 当前服务器最高的被应用于状态机的日志的索引, 初始化为0并单调递增  在状态为Leader的服务器上会额外存储的易失状态:
 nextIndex[]: 针对每个其他节点, 下一个需要发送的日志条目的索引, 初始化为leader最后一个日志索引+1 matchIndex[]: 针对每个其他节点, 当前所知的和Leader匹配的最高日志索引, 初始化为0并单调递增  Raft中RPC的种类 一. RequestVote
 candidate节点请求其他节点投票给自己
 请求参数:
 term: 当前candidate节点的term值 candidateId: 当前candidate节点的编号 lastLogIndex: 当前candidate节点最后一个日志的索引 lastLogTerm: 当前candidate节点最后一个日志的term值  返回值:
 term: 接受投票节点的term值, 主要用来更新当前candidate节点的term值 voteGranted: 是否给该申请节点投票  一个节点（无论当前是什么状态）在接收到RequestVote(term, candidateId, lastLogIndex, lastLogTerm)消息时, 其会做如下判断(条件从上往下依次判断):]]></description>
</item><item>
    <title>Algorithm </title>
    <link>https://Isaray.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</link>
    <pubDate>Sun, 31 Jan 2021 22:46:27 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</guid>
    <description><![CDATA[算法导论【复习】 教材：算法导论第三版
本博客内容均为自行整理，以供学过算法的同学快速回忆之用。
本人第一篇博客，当然要献给算法啦！博客是在复习的时候整理的，有点类似于记忆碎片，比较简略，欢迎大家在评论区讨论、补充、纠正。 ](算法导论期末复习大纲)
【算法复杂度】： 假设所需计算机资源的量只和问题规模、算法输入和算法本身的函数相关。
时间复杂度： 用基本操作步数衡量，独立于机器。 在不同情况下算法复杂度也是不同的，常见的情况有最好情况下，平均情况下，最坏情况下的时间复杂度。
首先，是时间复杂度的三个概念O(),$\theta$(),$\omega$()。
【算法导论】P26，三张图有助于理解
- $O$() 渐进上界  {f(n):存在正常量c,$n_0$，使得对所有n&gt;=$n_0$，有0&lt;=f(n)&lt;=cg(n)}
 - $\theta$() 渐进紧确界  {f(n):存在正常量$c_1$、$c_2$和$n_0$，使得对所有n&gt;=$n_0$，有0&lt;=$c_1$g(n)&lt;=f(n)&lt;=$c_2$g(n)}
 - $\Omega$() 渐进下界  {f(n):存在正常量c,$n_0$，使得对所有n&gt;=$n_0$，有0&lt;=cg(n)&lt;=f(n)}
  另外：
1.$\omicron$()代表非渐进紧确上界，$\omega$()代表非渐进紧确下界。o(g(n)) = {f(n): 对任意正常数c&gt;0，使得对所有n&gt;=$n_0$，有0&lt;=f(n)&lt;cg(n)}
2.$O()$和$\Omega$()如果非常紧的话都会趋向于$\theta$()。（有一种紧确界的证明方式就是这样的）
3.$O()$往往差了些也是对的，但是不准确，比如用O($n^{100}$)来描述快速排序的平均时间复杂度也是对的,但是不如O(nlogn)来得确切。所以比较紧的界才有意义，能求出$\theta$()最好啦。（另外，用$o(nlogn)$来描述快速排序的平均情况就不行，因为$\omicron$()代表非渐进紧确上界，看那个定义中是没有等号的，要注意大O和小o的区别）。
 根据递归式求$O$()和 $\Omega$()的三种方法：  代入法P48：猜测复杂度式子，假设出来（可能需要带低阶的参数），代入递归式并证明。 递归树法P50：把递归树画出来，然后累加（可能会用到级数相关知识）。那种分成两颗不均匀子树的情况常用这种方法求解。 主方法P53：可以用递归树法推导，推导过程中会用到$n^{log_ba} = a^{log_bn}$的性质P56。  令a$\ge$1和b&gt;1是常数，f(n)是一个函数，T(n)是定义在非负整数上的递归式： T(n) = a * T(n/b) + f(n)，其中我们将n/b解释为$\lfloor n/b\rfloor$或者$\lceil n/b\rceil$。那么T(n)有如下渐进界。
   对某个常数$\epsilon&gt;0$，有 f(n) = $O(n^{log_ba−\epsilon})$, 则 T(n) = $\theta(n^{log_ba})$。（叶子节点占主导）    f(n) = $\theta(n^{log_ba})$, 则 T(n) = $\theta(n^{log_ba}logn)$ 。（根节点叶子结点差不多）    对某个常数$\epsilon&gt;0$，有 f(n) = $\Omega(n^{log_ba−\epsilon})$, 且对某个常数c&lt;1和所有足够大的n有$af(n/b)\le cf(n)$，则 T(n) = $\theta(f(n))$。（根节点占主导）    strassen算法 书中有穿插着讲矩阵乘法的strassen算法，以它的复杂度为例。P44有伪代码。一般针对方阵，不是方阵可以补成方阵。]]></description>
</item><item>
    <title>CSAPP:memory mountain</title>
    <link>https://Isaray.github.io/csapp-memory_mountain/</link>
    <pubDate>Sun, 31 Jan 2021 16:20:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/csapp-memory_mountain/</guid>
    <description><![CDATA[CSAPP:memory mountain 画memory mountain存储器山： https://blog.csdn.net/weixin_41724000/article/details/100072251 http://csapp.cs.cmu.edu/3e/students.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  /* mountain.]]></description>
</item><item>
    <title>CSAPP:shlab</title>
    <link>https://Isaray.github.io/csapp-shlab/</link>
    <pubDate>Sun, 31 Jan 2021 16:15:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/csapp-shlab/</guid>
    <description><![CDATA[CSAPP:shlab 该实验对应CSAPP第8章：异常控制流，可以先温习该章内容再做实验。
通读实验指南，了解实验目的：
简介 The purpose of this assignment is to become more familiar with the concepts of process control and signalling. You’ll do this by writing a simple Unix shell program that supports job control.
本实验的目的就是写一个简单的Unix shell，主要任务就是修改tsh.c文件，需修改以下7个函数。
   1.void eval(char *cmdline); //解释命令[70 lines]
  2.int builtin_cmd(char **argv);//识别命令是否为内置命令quit、jobs、fg、bg ，若是，则执行对应命令.[25 lines]
    quit命令会终止shell。 jobs 命令列出所有后台工作。 bg 命令通过发送一个 SIGCONT 信号重新启动，然后在后台运行。参数可以是 PID 或 JID。 fg 命令通过发送一个 SIGCONT 信号重新启动，然后在前台运行。     3.]]></description>
</item><item>
    <title>CSAPP:malloclab</title>
    <link>https://Isaray.github.io/csapp-malloclab/</link>
    <pubDate>Sun, 31 Jan 2021 16:10:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/csapp-malloclab/</guid>
    <description><![CDATA[CSAPP:malloclab CSAPP:9.9.12 针对空闲块的组织方法有以下三种：
 a.隐式空闲链表(implicit free list) b.显式空闲链表(explicit free list) c.分离空闲链表(segregated free list)  查找空闲块的三个方法：
 a.首次适应(first fit) b.最佳适配(best fit) c.下一次适配(next fit) d.分离适配，特殊情况包括伙伴系统，优点在于快速搜索和快速合并（大小相同，地址连续）。  方案一：隐式空闲链表+first fit/next fit
 初始化堆 —— mm_init函数 mm_init步骤如下：  首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。
调extend_heap扩展堆，创建初始的空闲块，大小为4096字节。
扩展堆 —— extend_heap函数 函数原型: static void *extend_heap(size_t words);  以下两种场景需要扩展堆：
 调用mm_init初始化堆时。 调用mm_malloc找不到合适的空闲块时。
 释放和合并块 —— mm_free和coalesce函数   调用mm_free释放块，步骤如下： 将当前块的头部和脚部中的分配位清零。 将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。
 调用coalesce合并前后的合并块，原型：static void *coalesce(void *bp);，分四种情况：
 情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。 情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp 情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp) 情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回PREV_BLKP(bp)]]></description>
</item><item>
    <title>CSAPP:bomblab</title>
    <link>https://Isaray.github.io/csapp-bomblab/</link>
    <pubDate>Sun, 31 Jan 2021 16:05:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/csapp-bomblab/</guid>
    <description><![CDATA[CSAPP:bomblab Bomblab拆弹实录 准备工作 调试环境：  云主机Linux环境+GDB
 ssh客户端：  xshell+xftp/putty+psftp
 xshell+xftp:上传和下载文件有可视化操作界面，直接拖拽就可以上传。但是在gdb调试的时候，输入了的数据不能修改，按回车会输入^H，有的时候会手误就要重新开始。 putty+psftp：上传文件用scp命令（例如：scp hello.c xx@xxx.75.241.219/home/xx/lab0；scp -r 拷贝目录），下载文件可以用psftp。假设要下载到本地目录E:,在psftp中运行lcd E:\定位本地目录，putty切换到云主机目录之后，get 文件名即可下载。   Linux相关命令 ：   cd document切换到文件夹; cd ..返回上一级目录;ls显示文件夹中的文件;pwd当前目录位置 解压:tar -xf all.tar，tar -zxvf filename.tar.gz cat filename 显示文件内容 vim filename查看/编辑文件内容，i进入编辑模式，esc退出编辑模式，:wq保存并退出，:q没修改直接退出。 复制文件：cp document/file newdocument/newfile 重命名：mv oldname newname   GDB调试：   进入GDB调试状态，gdb filename;或先运行gdb再运行file filename info b看断点情况；b(reak) 行号/函数名 打断点；d (elete) 行号/函数名 删除断点 i r看寄存器的值。info reg esp看%esp里存储了什么。print $eax。print (char*) $ebx。 x/s 0xffff5330 打印该地址存储的字符串；x/16x 地址 答应之后16个字节的数字。 s单步执行（不会进入被调用的函数内部），si单步执行（会进入被调用的函数内部）。c接着运行到下一个断点。 display /ni $pc。用si调试每行都会显示下一行的汇编语言。   题目求解 phase_1:地址字符串  比较字符串是否相等，查看地址中预设的字符串即可。]]></description>
</item><item>
    <title>CSAPP:datalab</title>
    <link>https://Isaray.github.io/csapp-datalab/</link>
    <pubDate>Sun, 31 Jan 2021 16:00:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://Isaray.github.io/csapp-datalab/</guid>
    <description><![CDATA[CSAPP:datalab 代码中有具体思路的标注。 以下为实验的说明，每道题目中有规定一些运算符能否使用，使用的符号个数，并规定一些控制结构和函数不能使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  /* * CS:APP Data Lab * * * bits.]]></description>
</item></channel>
</rss>
